/*
 * Copyright (C) 2026 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.android.navigation.inertial.calibration

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.location.Location
import android.os.SystemClock
import android.util.Log
import com.irurueta.algebra.Matrix
import com.irurueta.algebra.WrongSizeException
import com.irurueta.android.navigation.inertial.GravityHelper
import com.irurueta.android.navigation.inertial.calibration.intervals.ErrorReason
import com.irurueta.android.navigation.inertial.calibration.intervals.measurements.AccelerometerGyroscopeAndMagnetometerMeasurementGenerator
import com.irurueta.android.navigation.inertial.calibration.noise.AccumulatedMeasurementEstimator
import com.irurueta.android.navigation.inertial.calibration.noise.GravityNormEstimator
import com.irurueta.android.navigation.inertial.collectors.SensorDelay
import com.irurueta.android.navigation.inertial.collectors.measurements.AccelerometerSensorType
import com.irurueta.android.navigation.inertial.collectors.measurements.GyroscopeSensorType
import com.irurueta.android.navigation.inertial.collectors.measurements.MagnetometerSensorType
import com.irurueta.android.navigation.inertial.toNEDPosition
import com.irurueta.android.testutils.callPrivateFuncWithResult
import com.irurueta.android.testutils.getPrivateProperty
import com.irurueta.android.testutils.setPrivateProperty
import com.irurueta.geometry.Quaternion
import com.irurueta.navigation.frames.CoordinateTransformation
import com.irurueta.navigation.frames.ECEFFrame
import com.irurueta.navigation.frames.FrameType
import com.irurueta.navigation.frames.NEDFrame
import com.irurueta.navigation.frames.converters.NEDtoECEFFrameConverter
import com.irurueta.navigation.inertial.BodyKinematics
import com.irurueta.navigation.inertial.BodyMagneticFluxDensity
import com.irurueta.navigation.inertial.calibration.AccelerationTriad
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad
import com.irurueta.navigation.inertial.calibration.BodyKinematicsGenerator
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence
import com.irurueta.navigation.inertial.calibration.BodyMagneticFluxDensityGenerator
import com.irurueta.navigation.inertial.calibration.CalibrationException
import com.irurueta.navigation.inertial.calibration.IMUErrors
import com.irurueta.navigation.inertial.calibration.MagneticFluxDensityTriad
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyKinematics
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyMagneticFluxDensity
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics
import com.irurueta.navigation.inertial.calibration.accelerometer.AccelerometerNonLinearCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.KnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.KnownBiasAndPositionAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.KnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.KnownPositionAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.LMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.LMedSRobustKnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.MSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.MSACRobustKnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.PROMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.PROMedSRobustKnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.PROSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.PROSACRobustKnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.RANSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.accelerometer.RANSACRobustKnownGravityNormAccelerometerCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.EasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.GyroscopeNonLinearCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.LMedSRobustEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.LMedSRobustKnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.MSACRobustEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.MSACRobustKnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.PROMedSRobustEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.PROMedSRobustKnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.PROSACRobustEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.PROSACRobustKnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.QuaternionIntegrator
import com.irurueta.navigation.inertial.calibration.gyroscope.QuaternionStepIntegratorType
import com.irurueta.navigation.inertial.calibration.gyroscope.RANSACRobustEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.gyroscope.RANSACRobustKnownBiasEasyGyroscopeCalibrator
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector
import com.irurueta.navigation.inertial.calibration.intervals.thresholdfactor.DefaultAccelerometerQualityScoreMapper
import com.irurueta.navigation.inertial.calibration.intervals.thresholdfactor.DefaultGyroscopeQualityScoreMapper
import com.irurueta.navigation.inertial.calibration.intervals.thresholdfactor.DefaultMagnetometerQualityScoreMapper
import com.irurueta.navigation.inertial.calibration.magnetometer.KnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.KnownHardIronPositionAndInstantMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.KnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.KnownPositionAndInstantMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.LMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.LMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.MSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.MSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.MagnetometerNonLinearCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.PROMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.PROMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.PROSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.PROSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.RANSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.calibration.magnetometer.RANSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
import com.irurueta.navigation.inertial.estimators.BodyMagneticFluxDensityEstimator
import com.irurueta.navigation.inertial.estimators.ECEFKinematicsEstimator
import com.irurueta.navigation.inertial.wmm.WMMEarthMagneticFluxDensityEstimator
import com.irurueta.navigation.inertial.wmm.WorldMagneticModel
import com.irurueta.numerical.robust.RobustEstimatorMethod
import com.irurueta.statistics.UniformRandomizer
import com.irurueta.units.Acceleration
import com.irurueta.units.AccelerationUnit
import com.irurueta.units.AngularSpeed
import com.irurueta.units.AngularSpeedUnit
import com.irurueta.units.MagneticFluxDensity
import com.irurueta.units.MagneticFluxDensityUnit
import com.irurueta.units.Time
import com.irurueta.units.TimeUnit
import io.mockk.Called
import io.mockk.every
import io.mockk.impl.annotations.MockK
import io.mockk.junit4.MockKRule
import io.mockk.justRun
import io.mockk.mockkStatic
import io.mockk.spyk
import io.mockk.verify
import org.junit.Assert.*
import org.junit.Rule
import org.junit.Test
import java.lang.reflect.InvocationTargetException
import java.util.Date
import java.util.GregorianCalendar
import java.util.Random
import kotlin.math.max
import kotlin.math.sqrt

class StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibratorTest {

    @get:Rule
    val mockkRule = MockKRule(this)

    @MockK(relaxUnitFun = true)
    private lateinit var initializationStartedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnInitializationStartedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var initializationCompletedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnInitializationCompletedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var errorListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnErrorListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var staticIntervalDetectedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnStaticIntervalDetectedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var dynamicIntervalDetectedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnDynamicIntervalDetectedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var staticIntervalSkippedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnStaticIntervalSkippedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var dynamicIntervalSkippedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnDynamicIntervalSkippedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var generatedAccelerometerMeasurementListener:
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator.OnGeneratedAccelerometerMeasurementListener

    @MockK(relaxUnitFun = true)
    private lateinit var generatedGyroscopeMeasurementListener:
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator.OnGeneratedGyroscopeMeasurementListener

    @MockK(relaxUnitFun = true)
    private lateinit var generatedMagnetometerMeasurementListener:
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator.OnGeneratedMagnetometerMeasurementListener

    @MockK(relaxUnitFun = true)
    private lateinit var readyToSolveCalibrationListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnReadyToSolveCalibrationListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var calibrationSolvingStartedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnCalibrationSolvingStartedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var calibrationCompletedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnCalibrationCompletedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var stoppedListener:
            StaticIntervalWithMeasurementGeneratorCalibrator.OnStoppedListener<StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator>

    @MockK(relaxUnitFun = true)
    private lateinit var unreliableGravityNormEstimationListener:
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator.OnUnreliableGravityEstimationListener

    @MockK
    private lateinit var generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator

    @MockK
    private lateinit var gravityNormEstimator: GravityNormEstimator

    @MockK
    private lateinit var accelerometerNonLinearInternalCalibrator: AccelerometerNonLinearCalibrator

    @MockK
    private lateinit var gyroscopeNonLinearInternalCalibrator: GyroscopeNonLinearCalibrator

    @MockK
    private lateinit var magnetometerNonLinearInternalCalibrator: MagnetometerNonLinearCalibrator

    @MockK
    private lateinit var accelerometerInternalCalibrator: KnownBiasAndPositionAccelerometerCalibrator

    @MockK
    private lateinit var magneticFluxMeasurement: StandardDeviationBodyMagneticFluxDensity

    @MockK
    private lateinit var location: Location

    @MockK
    private lateinit var measurement: StandardDeviationBodyKinematics

    @MockK
    private lateinit var context: Context

    @MockK
    private lateinit var sensorManager: SensorManager

    @MockK
    private lateinit var accelerometerSensor: Sensor

    @MockK
    private lateinit var gyroscopeSensor: Sensor

    @MockK
    private lateinit var magnetometerSensor: Sensor

    @MockK
    private lateinit var gravitySensor: Sensor

    @Test
    fun constructor_whenContext_returnsDefaultValues() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertSame(context, calibrator.context)
        assertNull(calibrator.location)
        assertNotNull(calibrator.timestamp)
        assertNull(calibrator.worldMagneticModel)
        assertTrue(calibrator.isInitialMagneticFluxDensityNormMeasured)
        assertTrue(calibrator.isGravityNormEstimated)
        assertEquals(
            AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED,
            calibrator.accelerometerSensorType
        )
        assertEquals(
            GyroscopeSensorType.GYROSCOPE_UNCALIBRATED,
            calibrator.gyroscopeSensorType
        )
        assertEquals(
            MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED,
            calibrator.magnetometerSensorType
        )
        assertEquals(SensorDelay.FASTEST, calibrator.accelerometerSensorDelay)
        assertEquals(SensorDelay.FASTEST, calibrator.gyroscopeSensorDelay)
        assertEquals(SensorDelay.FASTEST, calibrator.magnetometerSensorDelay)
        assertTrue(calibrator.solveCalibrationWhenEnoughMeasurements)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertNull(calibrator.initializationStartedListener)
        assertNull(calibrator.initializationCompletedListener)
        assertNull(calibrator.errorListener)
        assertNull(calibrator.staticIntervalDetectedListener)
        assertNull(calibrator.dynamicIntervalDetectedListener)
        assertNull(calibrator.staticIntervalSkippedListener)
        assertNull(calibrator.dynamicIntervalSkippedListener)
        assertNull(calibrator.generatedAccelerometerMeasurementListener)
        assertNull(calibrator.generatedGyroscopeMeasurementListener)
        assertNull(calibrator.generatedMagnetometerMeasurementListener)
        assertNull(calibrator.readyToSolveCalibrationListener)
        assertNull(calibrator.calibrationSolvingStartedListener)
        assertNull(calibrator.calibrationCompletedListener)
        assertNull(calibrator.stoppedListener)
        assertNull(calibrator.unreliableGravityNormEstimationListener)
        assertNotNull(calibrator.accelerometerQualityScoreMapper)
        assertNotNull(calibrator.gyroscopeQualityScoreMapper)
        assertNotNull(calibrator.magnetometerQualityScoreMapper)
        assertNull(calibrator.initialMagneticFluxDensityNorm)
        assertNull(calibrator.gravityNorm)
        assertFalse(calibrator.accelerometerResultUnreliable)
        assertNull(calibrator.accelerometerInitialBiasX)
        assertNull(calibrator.accelerometerInitialBiasY)
        assertNull(calibrator.accelerometerInitialBiasZ)
        assertNull(calibrator.accelerometerInitialBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerInitialBiasXAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasYAsMeasurement)
        assertFalse(calibrator.getAccelerometerInitialBiasYAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasZAsMeasurement)
        assertFalse(calibrator.getAccelerometerInitialBiasZAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasAsTriad)
        val accelerationTriad = AccelerationTriad()
        assertFalse(calibrator.getAccelerometerInitialBiasAsTriad(accelerationTriad))
        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.gyroscopeInitialBiasXAsMeasurement)
        val angularSpeed = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeInitialBiasXAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasYAsMeasurement)
        assertFalse(calibrator.getGyroscopeInitialBiasYAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasZAsMeasurement)
        assertFalse(calibrator.getGyroscopeInitialBiasZAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertFalse(calibrator.getGyroscopeInitialBiasAsTriad(angularSpeedTriad))
        assertNull(calibrator.magnetometerInitialHardIronX)
        assertNull(calibrator.magnetometerInitialHardIronY)
        assertNull(calibrator.magnetometerInitialHardIronZ)
        assertNull(calibrator.magnetometerInitialHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerInitialHardIronXAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronYAsMeasurement)
        assertFalse(calibrator.getMagnetometerInitialHardIronYAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronZAsMeasurement)
        assertFalse(calibrator.getMagnetometerInitialHardIronZAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertFalse(calibrator.getMagnetometerInitialHardIronAsTriad(triad))
        assertSame(accelerometerSensor, calibrator.accelerometerSensor)
        assertSame(gyroscopeSensor, calibrator.gyroscopeSensor)
        assertSame(magnetometerSensor, calibrator.magnetometerSensor)
        assertSame(gravitySensor, calibrator.gravitySensor)
        val accelerometerInitialMa1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelerometerInitialMa2 = calibrator.accelerometerInitialMa
        assertEquals(accelerometerInitialMa1, accelerometerInitialMa2)
        val accelerometerInitialMa3 =
            Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        calibrator.getAccelerometerInitialMa(accelerometerInitialMa3)
        assertEquals(accelerometerInitialMa1, accelerometerInitialMa3)
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)
        val gyroscopeInitialMg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val gyroscopeInitialMg2 = calibrator.gyroscopeInitialMg
        assertEquals(gyroscopeInitialMg1, gyroscopeInitialMg2)
        val gyroscopeInitialMg3 =
            Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        calibrator.getGyroscopeInitialMg(gyroscopeInitialMg3)
        assertEquals(gyroscopeInitialMg1, gyroscopeInitialMg3)
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzy, 0.0)
        val gyroscopeInitialGg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val gyroscopeInitialGg2 = calibrator.gyroscopeInitialGg
        assertEquals(gyroscopeInitialGg1, gyroscopeInitialGg2)
        val mm1 = Matrix(MM_SIZE, MM_SIZE)
        assertEquals(mm1, calibrator.magnetometerInitialMm)
        val mm2 = Matrix.identity(MM_SIZE, MM_SIZE)
        calibrator.getMagnetometerInitialMm(mm2)
        assertEquals(mm1, mm2)
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)
        assertFalse(calibrator.isAccelerometerCommonAxisUsed)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isMagnetometerCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ACCELEROMETER_UNKNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.minimumRequiredAccelerometerMeasurements
        )
        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.minimumRequiredGyroscopeMeasurements
        )
        assertEquals(
            StaticIntervalMagnetometerCalibrator.MAGNETOMETER_UNKNOWN_HARD_IRON_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.minimumRequiredMagnetometerMeasurements
        )
        assertEquals(
            max(
                max(
                    calibrator.minimumRequiredAccelerometerMeasurements,
                    calibrator.minimumRequiredGyroscopeMeasurements
                ), calibrator.minimumRequiredMagnetometerMeasurements
            ), calibrator.minimumRequiredMeasurements
        )
        assertNull(calibrator.averageGravityNorm)
        assertNull(calibrator.averageGravityNormAsMeasurement)
        assertFalse(calibrator.getAverageGravityNormAsMeasurement(acceleration))
        assertNull(calibrator.gravityNormVariance)
        assertNull(calibrator.gravityNormStandardDeviation)
        assertNull(calibrator.gravityNormStandardDeviationAsMeasurement)
        assertFalse(calibrator.getGravityNormStandardDeviationAsMeasurement(acceleration))
        assertNull(calibrator.gravityPsd)
        assertNull(calibrator.gravityRootPsd)
        assertNull(calibrator.accelerometerRobustMethod)
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.accelerometerRobustConfidence,
            0.0
        )
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.accelerometerRobustMaxIterations
        )
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        assertNull(calibrator.accelerometerRobustThreshold)
        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustThresholdFactor,
            0.0
        )
        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.gyroscopeRobustMethod)
        assertEquals(
            StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.gyroscopeRobustConfidence,
            0.0
        )
        assertEquals(
            StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.gyroscopeRobustMaxIterations
        )
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        assertNull(calibrator.gyroscopeRobustThreshold)
        assertEquals(
            StaticIntervalGyroscopeCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustThresholdFactor,
            0.0
        )
        assertEquals(
            StaticIntervalGyroscopeCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.magnetometerRobustMethod)
        assertEquals(
            SingleSensorStaticIntervalMagnetometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.magnetometerRobustConfidence,
            0.0
        )
        assertEquals(
            SingleSensorStaticIntervalMagnetometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.magnetometerRobustMaxIterations
        )
        assertEquals(
            SingleSensorStaticIntervalMagnetometerCalibrator.UNKNOWN_HARD_IRON_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        assertNull(calibrator.magnetometerRobustThreshold)
        assertEquals(
            SingleSensorStaticIntervalMagnetometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustThresholdFactor,
            0.0
        )
        assertEquals(
            SingleSensorStaticIntervalMagnetometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.estimatedAccelerometerMa)
        assertNull(calibrator.estimatedAccelerometerSx)
        assertNull(calibrator.estimatedAccelerometerSy)
        assertNull(calibrator.estimatedAccelerometerSz)
        assertNull(calibrator.estimatedAccelerometerMxy)
        assertNull(calibrator.estimatedAccelerometerMxz)
        assertNull(calibrator.estimatedAccelerometerMyx)
        assertNull(calibrator.estimatedAccelerometerMyz)
        assertNull(calibrator.estimatedAccelerometerMzx)
        assertNull(calibrator.estimatedAccelerometerMzy)
        assertNull(calibrator.estimatedAccelerometerCovariance)
        assertNull(calibrator.estimatedAccelerometerChiSq)
        assertNull(calibrator.estimatedAccelerometerMse)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasAsTriad)
        assertFalse(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerationTriad))
        assertNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)
        assertNull(calibrator.estimatedGyroscopeMg)
        assertNull(calibrator.estimatedGyroscopeSx)
        assertNull(calibrator.estimatedGyroscopeSy)
        assertNull(calibrator.estimatedGyroscopeSz)
        assertNull(calibrator.estimatedGyroscopeMxy)
        assertNull(calibrator.estimatedGyroscopeMxz)
        assertNull(calibrator.estimatedGyroscopeMyx)
        assertNull(calibrator.estimatedGyroscopeMyz)
        assertNull(calibrator.estimatedGyroscopeMzx)
        assertNull(calibrator.estimatedGyroscopeMzy)
        assertNull(calibrator.estimatedGyroscopeGg)
        assertNull(calibrator.estimatedGyroscopeCovariance)
        assertNull(calibrator.estimatedGyroscopeChiSq)
        assertNull(calibrator.estimatedGyroscopeMse)
        assertNull(calibrator.estimatedGyroscopeBiasX)
        assertNull(calibrator.estimatedGyroscopeBiasY)
        assertNull(calibrator.estimatedGyroscopeBiasZ)
        assertNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasAsTriad)
        assertFalse(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)
        assertNull(calibrator.estimatedMagnetometerMm)
        assertNull(calibrator.estimatedMagnetometerSx)
        assertNull(calibrator.estimatedMagnetometerSy)
        assertNull(calibrator.estimatedMagnetometerSz)
        assertNull(calibrator.estimatedMagnetometerMxy)
        assertNull(calibrator.estimatedMagnetometerMxz)
        assertNull(calibrator.estimatedMagnetometerMyx)
        assertNull(calibrator.estimatedMagnetometerMyz)
        assertNull(calibrator.estimatedMagnetometerMzx)
        assertNull(calibrator.estimatedMagnetometerMzy)
        assertNull(calibrator.estimatedMagnetometerCovariance)
        assertNull(calibrator.estimatedMagnetometerChiSq)
        assertNull(calibrator.estimatedMagnetometerMse)
        assertNull(calibrator.estimatedMagnetometerHardIronX)
        assertNull(calibrator.estimatedMagnetometerHardIronY)
        assertNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
        assertNull(calibrator.gyroscopeBaseNoiseLevel)
        assertNull(calibrator.gyroscopeBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getGyroscopeBaseNoiseLevelAsMeasurement(angularSpeed))
        assertNull(calibrator.magnetometerBaseNoiseLevel)
        assertNull(calibrator.magnetometerBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getMagnetometerBaseNoiseLevelAsMeasurement(b))
        assertEquals(0, calibrator.numberOfProcessedGyroscopeMeasurements)
        assertEquals(0, calibrator.numberOfProcessedMagnetometerMeasurements)
        assertTrue(calibrator.accelerometerMeasurements.isEmpty())
        assertTrue(calibrator.gyroscopeMeasurements.isEmpty())
        assertTrue(calibrator.magnetometerMeasurements.isEmpty())
        assertFalse(calibrator.isReadyToSolveAccelerometerCalibration)
        assertFalse(calibrator.isReadyToSolveGyroscopeCalibration)
        assertFalse(calibrator.isReadyToSolveMagnetometerCalibration)
        assertFalse(calibrator.isReadyToSolveCalibration)
        assertFalse(calibrator.running)
        assertEquals(TriadStaticIntervalDetector.DEFAULT_WINDOW_SIZE, calibrator.windowSize)
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INITIAL_STATIC_SAMPLES,
            calibrator.initialStaticSamples
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_THRESHOLD_FACTOR,
            calibrator.thresholdFactor,
            0.0
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR,
            calibrator.instantaneousNoiseLevelFactor,
            0.0
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            calibrator.baseNoiseLevelAbsoluteThreshold,
            0.0
        )
        val baseNoiseLevel1 = calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement
        assertEquals(
            calibrator.baseNoiseLevelAbsoluteThreshold,
            baseNoiseLevel1.value.toDouble(),
            0.0
        )
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, baseNoiseLevel1.unit)
        val baseNoiseLevel2 = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        calibrator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(baseNoiseLevel2)
        assertEquals(baseNoiseLevel1, baseNoiseLevel2)
        assertNull(calibrator.accelerometerBaseNoiseLevel)
        assertNull(calibrator.accelerometerBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getAccelerometerBaseNoiseLevelAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerBaseNoiseLevelPsd)
        assertNull(calibrator.accelerometerBaseNoiseLevelRootPsd)
        assertNull(calibrator.threshold)
        assertNull(calibrator.thresholdAsMeasurement)
        assertFalse(calibrator.getThresholdAsMeasurement(acceleration))
        assertEquals(0, calibrator.processedStaticSamples)
        assertEquals(0, calibrator.processedDynamicSamples)
        assertFalse(calibrator.isStaticIntervalSkipped)
        assertFalse(calibrator.isDynamicIntervalSkipped)
        assertNull(calibrator.accelerometerAverageTimeInterval)
        assertNull(calibrator.accelerometerAverageTimeIntervalAsTime)
        val time = Time(0.0, TimeUnit.SECOND)
        assertFalse(calibrator.getAccelerometerAverageTimeIntervalAsTime(time))
        assertNull(calibrator.accelerometerTimeIntervalVariance)
        assertNull(calibrator.accelerometerTimeIntervalStandardDeviation)
        assertNull(calibrator.accelerometerTimeIntervalStandardDeviationAsTime)
        assertFalse(calibrator.getAccelerometerTimeIntervalStandardDeviationAsTime(time))
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ACCELEROMETER_UNKNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.requiredMeasurements
        )
        assertEquals(0, calibrator.numberOfProcessedAccelerometerMeasurements)
    }

    @Test
    fun constructor_whenAllParameters_returnsExpectedValues() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val location = getLocation()
        val timestamp = Date()
        val worldMagneticModel = WorldMagneticModel()
        val accelerometerQualityScoreMapper = DefaultAccelerometerQualityScoreMapper()
        val gyroscopeQualityScoreMapper = DefaultGyroscopeQualityScoreMapper()
        val magnetometerQualityScoreMapper = DefaultMagnetometerQualityScoreMapper()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location,
            timestamp,
            worldMagneticModel,
            AccelerometerSensorType.ACCELEROMETER,
            GyroscopeSensorType.GYROSCOPE,
            MagnetometerSensorType.MAGNETOMETER,
            SensorDelay.NORMAL,
            SensorDelay.NORMAL,
            SensorDelay.NORMAL,
            solveCalibrationWhenEnoughMeasurements = false,
            isAccelerometerGroundTruthInitialBias = true,
            isGyroscopeGroundTruthInitialBias = true,
            isMagnetometerGroundTruthInitialHardIron = true,
            initializationStartedListener,
            initializationCompletedListener,
            errorListener,
            staticIntervalDetectedListener,
            dynamicIntervalDetectedListener,
            staticIntervalSkippedListener,
            dynamicIntervalSkippedListener,
            generatedAccelerometerMeasurementListener,
            generatedGyroscopeMeasurementListener,
            generatedMagnetometerMeasurementListener,
            readyToSolveCalibrationListener,
            calibrationSolvingStartedListener,
            calibrationCompletedListener,
            stoppedListener,
            unreliableGravityNormEstimationListener,
            accelerometerQualityScoreMapper,
            gyroscopeQualityScoreMapper,
            magnetometerQualityScoreMapper
        )

        // check default values
        assertSame(context, calibrator.context)
        assertSame(location, calibrator.location)
        assertSame(timestamp, calibrator.timestamp)
        assertSame(worldMagneticModel, calibrator.worldMagneticModel)
        assertFalse(calibrator.isInitialMagneticFluxDensityNormMeasured)
        assertFalse(calibrator.isGravityNormEstimated)
        assertEquals(
            AccelerometerSensorType.ACCELEROMETER,
            calibrator.accelerometerSensorType
        )
        assertEquals(
            GyroscopeSensorType.GYROSCOPE,
            calibrator.gyroscopeSensorType
        )
        assertEquals(
            MagnetometerSensorType.MAGNETOMETER,
            calibrator.magnetometerSensorType
        )
        assertEquals(SensorDelay.NORMAL, calibrator.accelerometerSensorDelay)
        assertEquals(SensorDelay.NORMAL, calibrator.gyroscopeSensorDelay)
        assertEquals(SensorDelay.NORMAL, calibrator.magnetometerSensorDelay)
        assertFalse(calibrator.solveCalibrationWhenEnoughMeasurements)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertSame(initializationStartedListener, calibrator.initializationStartedListener)
        assertSame(initializationCompletedListener, calibrator.initializationCompletedListener)
        assertSame(errorListener, calibrator.errorListener)
        assertSame(staticIntervalDetectedListener, calibrator.staticIntervalDetectedListener)
        assertSame(dynamicIntervalDetectedListener, calibrator.dynamicIntervalDetectedListener)
        assertSame(staticIntervalSkippedListener, calibrator.staticIntervalSkippedListener)
        assertSame(dynamicIntervalSkippedListener, calibrator.dynamicIntervalSkippedListener)
        assertSame(
            generatedAccelerometerMeasurementListener,
            calibrator.generatedAccelerometerMeasurementListener
        )
        assertSame(
            generatedGyroscopeMeasurementListener,
            calibrator.generatedGyroscopeMeasurementListener
        )
        assertSame(
            generatedMagnetometerMeasurementListener,
            calibrator.generatedMagnetometerMeasurementListener
        )
        assertSame(readyToSolveCalibrationListener, calibrator.readyToSolveCalibrationListener)
        assertSame(calibrationSolvingStartedListener, calibrator.calibrationSolvingStartedListener)
        assertSame(calibrationCompletedListener, calibrator.calibrationCompletedListener)
        assertSame(stoppedListener, calibrator.stoppedListener)
        assertSame(
            unreliableGravityNormEstimationListener,
            calibrator.unreliableGravityNormEstimationListener
        )
        assertSame(accelerometerQualityScoreMapper, calibrator.accelerometerQualityScoreMapper)
        assertSame(gyroscopeQualityScoreMapper, calibrator.gyroscopeQualityScoreMapper)
        assertSame(magnetometerQualityScoreMapper, calibrator.magnetometerQualityScoreMapper)
        assertNull(calibrator.initialMagneticFluxDensityNorm)
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        assertEquals(gravityNorm, calibrator.gravityNorm)
        assertNull(calibrator.accelerometerInitialBiasX)
        assertNull(calibrator.accelerometerInitialBiasY)
        assertNull(calibrator.accelerometerInitialBiasZ)
        assertNull(calibrator.accelerometerInitialBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerInitialBiasXAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasYAsMeasurement)
        assertFalse(calibrator.getAccelerometerInitialBiasYAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasZAsMeasurement)
        assertFalse(calibrator.getAccelerometerInitialBiasZAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerInitialBiasAsTriad)
        val accelerationTriad = AccelerationTriad()
        assertFalse(calibrator.getAccelerometerInitialBiasAsTriad(accelerationTriad))
        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.gyroscopeInitialBiasXAsMeasurement)
        val angularSpeed = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeInitialBiasXAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasYAsMeasurement)
        assertFalse(calibrator.getGyroscopeInitialBiasYAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasZAsMeasurement)
        assertFalse(calibrator.getGyroscopeInitialBiasZAsMeasurement(angularSpeed))
        assertNull(calibrator.gyroscopeInitialBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertFalse(calibrator.getGyroscopeInitialBiasAsTriad(angularSpeedTriad))
        assertNull(calibrator.magnetometerInitialHardIronX)
        assertNull(calibrator.magnetometerInitialHardIronY)
        assertNull(calibrator.magnetometerInitialHardIronZ)
        assertNull(calibrator.magnetometerInitialHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerInitialHardIronXAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronYAsMeasurement)
        assertFalse(calibrator.getMagnetometerInitialHardIronYAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronZAsMeasurement)
        assertFalse(calibrator.getMagnetometerInitialHardIronZAsMeasurement(b))
        assertNull(calibrator.magnetometerInitialHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertFalse(calibrator.getMagnetometerInitialHardIronAsTriad(triad))
        assertSame(accelerometerSensor, calibrator.accelerometerSensor)
        assertSame(gyroscopeSensor, calibrator.gyroscopeSensor)
        assertSame(magnetometerSensor, calibrator.magnetometerSensor)
        assertSame(gravitySensor, calibrator.gravitySensor)
        val accelerometerInitialMa1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelerometerInitialMa2 = calibrator.accelerometerInitialMa
        assertEquals(accelerometerInitialMa1, accelerometerInitialMa2)
        val accelerometerInitialMa3 =
            Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        calibrator.getAccelerometerInitialMa(accelerometerInitialMa3)
        assertEquals(accelerometerInitialMa1, accelerometerInitialMa3)
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)
        val gyroscopeInitialMg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val gyroscopeInitialMg2 = calibrator.gyroscopeInitialMg
        assertEquals(gyroscopeInitialMg1, gyroscopeInitialMg2)
        val gyroscopeInitialMg3 =
            Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        calibrator.getGyroscopeInitialMg(gyroscopeInitialMg3)
        assertEquals(gyroscopeInitialMg1, gyroscopeInitialMg3)
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzy, 0.0)
        val gyroscopeInitialGg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val gyroscopeInitialGg2 = calibrator.gyroscopeInitialGg
        assertEquals(gyroscopeInitialGg1, gyroscopeInitialGg2)
        val mm1 = Matrix(MM_SIZE, MM_SIZE)
        assertEquals(mm1, calibrator.magnetometerInitialMm)
        val mm2 = Matrix.identity(MM_SIZE, MM_SIZE)
        calibrator.getMagnetometerInitialMm(mm2)
        assertEquals(mm1, mm2)
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)
        assertFalse(calibrator.isAccelerometerCommonAxisUsed)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isMagnetometerCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalAccelerometerCalibrator.ACCELEROMETER_KNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.minimumRequiredAccelerometerMeasurements
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.GYROSCOPE_KNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.minimumRequiredGyroscopeMeasurements
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalMagnetometerCalibrator.MAGNETOMETER_KNOWN_HARD_IRON_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.minimumRequiredMagnetometerMeasurements
        )
        assertEquals(
            max(
                max(
                    calibrator.minimumRequiredAccelerometerMeasurements,
                    calibrator.minimumRequiredGyroscopeMeasurements
                ), calibrator.minimumRequiredMagnetometerMeasurements
            ), calibrator.minimumRequiredMeasurements
        )
        assertNull(calibrator.averageGravityNorm)
        assertNull(calibrator.averageGravityNormAsMeasurement)
        assertFalse(calibrator.getAverageGravityNormAsMeasurement(acceleration))
        assertNull(calibrator.gravityNormVariance)
        assertNull(calibrator.gravityNormStandardDeviation)
        assertNull(calibrator.gravityNormStandardDeviationAsMeasurement)
        assertFalse(calibrator.getGravityNormStandardDeviationAsMeasurement(acceleration))
        assertNull(calibrator.gravityPsd)
        assertNull(calibrator.gravityRootPsd)
        assertNull(calibrator.accelerometerRobustMethod)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.accelerometerRobustConfidence,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.accelerometerRobustMaxIterations
        )
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        assertNull(calibrator.accelerometerRobustThreshold)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustThresholdFactor,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.gyroscopeRobustMethod)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.gyroscopeRobustConfidence,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.gyroscopeRobustMaxIterations
        )
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        assertNull(calibrator.gyroscopeRobustThreshold)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustThresholdFactor,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.magnetometerRobustMethod)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.SingleSensorStaticIntervalMagnetometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.magnetometerRobustConfidence,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.SingleSensorStaticIntervalMagnetometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.magnetometerRobustMaxIterations
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.SingleSensorStaticIntervalMagnetometerCalibrator.KNOWN_HARD_IRON_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        assertNull(calibrator.magnetometerRobustThreshold)
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.SingleSensorStaticIntervalMagnetometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustThresholdFactor,
            0.0
        )
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.SingleSensorStaticIntervalMagnetometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustStopThresholdFactor,
            0.0
        )
        assertNull(calibrator.estimatedAccelerometerMa)
        assertNull(calibrator.estimatedAccelerometerSx)
        assertNull(calibrator.estimatedAccelerometerSy)
        assertNull(calibrator.estimatedAccelerometerSz)
        assertNull(calibrator.estimatedAccelerometerMxy)
        assertNull(calibrator.estimatedAccelerometerMxz)
        assertNull(calibrator.estimatedAccelerometerMyx)
        assertNull(calibrator.estimatedAccelerometerMyz)
        assertNull(calibrator.estimatedAccelerometerMzx)
        assertNull(calibrator.estimatedAccelerometerMzy)
        assertNull(calibrator.estimatedAccelerometerCovariance)
        assertNull(calibrator.estimatedAccelerometerChiSq)
        assertNull(calibrator.estimatedAccelerometerMse)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertFalse(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNull(calibrator.estimatedAccelerometerBiasAsTriad)
        assertFalse(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerationTriad))
        assertNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)
        assertNull(calibrator.estimatedGyroscopeMg)
        assertNull(calibrator.estimatedGyroscopeSx)
        assertNull(calibrator.estimatedGyroscopeSy)
        assertNull(calibrator.estimatedGyroscopeSz)
        assertNull(calibrator.estimatedGyroscopeMxy)
        assertNull(calibrator.estimatedGyroscopeMxz)
        assertNull(calibrator.estimatedGyroscopeMyx)
        assertNull(calibrator.estimatedGyroscopeMyz)
        assertNull(calibrator.estimatedGyroscopeMzx)
        assertNull(calibrator.estimatedGyroscopeMzy)
        assertNull(calibrator.estimatedGyroscopeGg)
        assertNull(calibrator.estimatedGyroscopeCovariance)
        assertNull(calibrator.estimatedGyroscopeChiSq)
        assertNull(calibrator.estimatedGyroscopeMse)
        assertNull(calibrator.estimatedGyroscopeBiasX)
        assertNull(calibrator.estimatedGyroscopeBiasY)
        assertNull(calibrator.estimatedGyroscopeBiasZ)
        assertNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertFalse(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(angularSpeed))
        assertNull(calibrator.estimatedGyroscopeBiasAsTriad)
        assertFalse(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)
        assertNull(calibrator.estimatedMagnetometerMm)
        assertNull(calibrator.estimatedMagnetometerSx)
        assertNull(calibrator.estimatedMagnetometerSy)
        assertNull(calibrator.estimatedMagnetometerSz)
        assertNull(calibrator.estimatedMagnetometerMxy)
        assertNull(calibrator.estimatedMagnetometerMxz)
        assertNull(calibrator.estimatedMagnetometerMyx)
        assertNull(calibrator.estimatedMagnetometerMyz)
        assertNull(calibrator.estimatedMagnetometerMzx)
        assertNull(calibrator.estimatedMagnetometerMzy)
        assertNull(calibrator.estimatedMagnetometerCovariance)
        assertNull(calibrator.estimatedMagnetometerChiSq)
        assertNull(calibrator.estimatedMagnetometerMse)
        assertNull(calibrator.estimatedMagnetometerHardIronX)
        assertNull(calibrator.estimatedMagnetometerHardIronY)
        assertNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
        assertNull(calibrator.gyroscopeBaseNoiseLevel)
        assertNull(calibrator.gyroscopeBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getGyroscopeBaseNoiseLevelAsMeasurement(angularSpeed))
        assertNull(calibrator.magnetometerBaseNoiseLevel)
        assertNull(calibrator.magnetometerBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getMagnetometerBaseNoiseLevelAsMeasurement(b))
        assertEquals(0, calibrator.numberOfProcessedGyroscopeMeasurements)
        assertEquals(0, calibrator.numberOfProcessedMagnetometerMeasurements)
        assertTrue(calibrator.accelerometerMeasurements.isEmpty())
        assertTrue(calibrator.gyroscopeMeasurements.isEmpty())
        assertTrue(calibrator.magnetometerMeasurements.isEmpty())
        assertFalse(calibrator.isReadyToSolveAccelerometerCalibration)
        assertFalse(calibrator.isReadyToSolveGyroscopeCalibration)
        assertFalse(calibrator.isReadyToSolveMagnetometerCalibration)
        assertFalse(calibrator.isReadyToSolveCalibration)
        assertFalse(calibrator.running)
        assertEquals(TriadStaticIntervalDetector.DEFAULT_WINDOW_SIZE, calibrator.windowSize)
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INITIAL_STATIC_SAMPLES,
            calibrator.initialStaticSamples
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_THRESHOLD_FACTOR,
            calibrator.thresholdFactor,
            0.0
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR,
            calibrator.instantaneousNoiseLevelFactor,
            0.0
        )
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            calibrator.baseNoiseLevelAbsoluteThreshold,
            0.0
        )
        val baseNoiseLevel1 = calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement
        assertEquals(
            calibrator.baseNoiseLevelAbsoluteThreshold,
            baseNoiseLevel1.value.toDouble(),
            0.0
        )
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, baseNoiseLevel1.unit)
        val baseNoiseLevel2 = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        calibrator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(baseNoiseLevel2)
        assertEquals(baseNoiseLevel1, baseNoiseLevel2)
        assertNull(calibrator.accelerometerBaseNoiseLevel)
        assertNull(calibrator.accelerometerBaseNoiseLevelAsMeasurement)
        assertFalse(calibrator.getAccelerometerBaseNoiseLevelAsMeasurement(acceleration))
        assertNull(calibrator.accelerometerBaseNoiseLevelPsd)
        assertNull(calibrator.accelerometerBaseNoiseLevelRootPsd)
        assertNull(calibrator.threshold)
        assertNull(calibrator.thresholdAsMeasurement)
        assertFalse(calibrator.getThresholdAsMeasurement(acceleration))
        assertEquals(0, calibrator.processedStaticSamples)
        assertEquals(0, calibrator.processedDynamicSamples)
        assertFalse(calibrator.isStaticIntervalSkipped)
        assertFalse(calibrator.isDynamicIntervalSkipped)
        assertNull(calibrator.accelerometerAverageTimeInterval)
        assertNull(calibrator.accelerometerAverageTimeIntervalAsTime)
        val time = Time(0.0, TimeUnit.SECOND)
        assertFalse(calibrator.getAccelerometerAverageTimeIntervalAsTime(time))
        assertNull(calibrator.accelerometerTimeIntervalVariance)
        assertNull(calibrator.accelerometerTimeIntervalStandardDeviation)
        assertNull(calibrator.accelerometerTimeIntervalStandardDeviationAsTime)
        assertFalse(calibrator.getAccelerometerTimeIntervalStandardDeviationAsTime(time))
        assertEquals(
            com.irurueta.android.navigation.inertial.old.calibration.StaticIntervalGyroscopeCalibrator.GYROSCOPE_KNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertEquals(0, calibrator.numberOfProcessedAccelerometerMeasurements)
    }

    @Test
    fun location_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.location)
        assertFalse(calibrator.running)
        assertTrue(calibrator.isGravityNormEstimated)

        // set new value
        val location = getLocation()
        calibrator.location = location

        // check
        assertSame(location, calibrator.location)
        assertFalse(calibrator.isGravityNormEstimated)
    }

    @Test
    fun location_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        // set new value
        val location = getLocation()
        assertThrows(IllegalStateException::class.java) {
            calibrator.location = location
        }
    }

    @Test
    fun timestamp_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNotNull(calibrator.timestamp)

        // set new value
        val timestamp = Date()
        calibrator.timestamp = timestamp

        // check
        assertSame(timestamp, calibrator.timestamp)
    }

    @Test
    fun timestamp_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        assertThrows(IllegalStateException::class.java) {
            calibrator.timestamp = Date()
        }
    }

    @Test
    fun worldMagneticModel_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.worldMagneticModel)

        // set new value
        val worldMagneticModel = WorldMagneticModel()
        calibrator.worldMagneticModel = worldMagneticModel

        // check
        assertSame(worldMagneticModel, calibrator.worldMagneticModel)
    }

    @Test
    fun worldMagneticModel_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        assertThrows(IllegalStateException::class.java) {
            calibrator.worldMagneticModel = WorldMagneticModel()
        }
    }

    @Test
    fun isInitialMagneticFluxDensityNormMeasured_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertTrue(calibrator.isInitialMagneticFluxDensityNormMeasured)
        assertNull(calibrator.location)
        assertNotNull(calibrator.timestamp)

        // set location
        val location = getLocation()
        calibrator.location = location

        // check
        assertFalse(calibrator.isInitialMagneticFluxDensityNormMeasured)
        assertSame(location, calibrator.location)
        assertNotNull(calibrator.timestamp)

        // unset timestamp
        calibrator.timestamp = null

        // check
        assertTrue(calibrator.isInitialMagneticFluxDensityNormMeasured)
        assertSame(location, calibrator.location)
        assertNull(calibrator.timestamp)
    }

    @Test
    fun initializationStartedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.initializationStartedListener)

        // set new value
        calibrator.initializationStartedListener = initializationStartedListener

        // check
        assertSame(initializationStartedListener, calibrator.initializationStartedListener)
    }

    @Test
    fun initializationCompletedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.initializationCompletedListener)

        // set new value
        calibrator.initializationCompletedListener = initializationCompletedListener

        // check
        assertSame(initializationCompletedListener, calibrator.initializationCompletedListener)
    }

    @Test
    fun errorListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.errorListener)

        // set new value
        calibrator.errorListener = errorListener

        // check
        assertSame(errorListener, calibrator.errorListener)
    }

    @Test
    fun staticIntervalDetectedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.staticIntervalDetectedListener)

        // set new value
        calibrator.staticIntervalDetectedListener = staticIntervalDetectedListener

        // check
        assertSame(staticIntervalDetectedListener, calibrator.staticIntervalDetectedListener)
    }

    @Test
    fun dynamicIntervalDetectedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.dynamicIntervalDetectedListener)

        // set new value
        calibrator.dynamicIntervalDetectedListener = dynamicIntervalDetectedListener

        // check
        assertSame(dynamicIntervalDetectedListener, calibrator.dynamicIntervalDetectedListener)
    }

    @Test
    fun staticIntervalSkippedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.staticIntervalSkippedListener)

        // set new value
        calibrator.staticIntervalSkippedListener = staticIntervalSkippedListener

        // check
        assertSame(staticIntervalSkippedListener, calibrator.staticIntervalSkippedListener)
    }

    @Test
    fun dynamicIntervalSkippedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.dynamicIntervalSkippedListener)

        // set new value
        calibrator.dynamicIntervalSkippedListener = dynamicIntervalSkippedListener

        // check
        assertSame(dynamicIntervalSkippedListener, calibrator.dynamicIntervalSkippedListener)
    }

    @Test
    fun generatedAccelerometerMeasurementListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.generatedAccelerometerMeasurementListener)

        // set new value
        calibrator.generatedAccelerometerMeasurementListener =
            generatedAccelerometerMeasurementListener

        // check
        assertSame(
            generatedAccelerometerMeasurementListener,
            calibrator.generatedAccelerometerMeasurementListener
        )
    }

    @Test
    fun generatedGyroscopeMeasurementListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.generatedGyroscopeMeasurementListener)

        // set new value
        calibrator.generatedGyroscopeMeasurementListener = generatedGyroscopeMeasurementListener

        // check
        assertSame(
            generatedGyroscopeMeasurementListener,
            calibrator.generatedGyroscopeMeasurementListener
        )
    }

    @Test
    fun generatedMagnetometerMeasurementListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.generatedMagnetometerMeasurementListener)

        // set new value
        calibrator.generatedMagnetometerMeasurementListener =
            generatedMagnetometerMeasurementListener

        // check
        assertSame(
            generatedMagnetometerMeasurementListener,
            calibrator.generatedMagnetometerMeasurementListener
        )
    }

    @Test
    fun readyToSolveCalibrationListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.readyToSolveCalibrationListener)

        // set new value
        calibrator.readyToSolveCalibrationListener = readyToSolveCalibrationListener

        // check
        assertSame(readyToSolveCalibrationListener, calibrator.readyToSolveCalibrationListener)
    }

    @Test
    fun calibrationSolvingStartedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.calibrationSolvingStartedListener)

        // set new value
        calibrator.calibrationSolvingStartedListener = calibrationSolvingStartedListener

        // check
        assertSame(calibrationSolvingStartedListener, calibrator.calibrationSolvingStartedListener)
    }

    @Test
    fun calibrationCompletedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.calibrationCompletedListener)

        // set new value
        calibrator.calibrationCompletedListener = calibrationCompletedListener

        // check
        assertSame(calibrationCompletedListener, calibrator.calibrationCompletedListener)
    }

    @Test
    fun stoppedListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.stoppedListener)

        // set new value
        calibrator.stoppedListener = stoppedListener

        // check
        assertSame(stoppedListener, calibrator.stoppedListener)
    }

    @Test
    fun unreliableGravityNormEstimationListener_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.unreliableGravityNormEstimationListener)

        // set new value
        calibrator.unreliableGravityNormEstimationListener = unreliableGravityNormEstimationListener

        // check
        assertSame(
            unreliableGravityNormEstimationListener,
            calibrator.unreliableGravityNormEstimationListener
        )
    }

    @Test
    fun isAccelerometerGroundTruthInitialBias_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)

        // set new value
        calibrator.isAccelerometerGroundTruthInitialBias = true

        // check
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
    }

    @Test
    fun isAccelerometerGroundTruthInitialBias_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        assertThrows(IllegalStateException::class.java) {
            calibrator.isAccelerometerGroundTruthInitialBias = true
        }
    }

    @Test
    fun isGyroscopeGroundTruthInitialBias_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)

        // set new value
        calibrator.isGyroscopeGroundTruthInitialBias = true

        // check
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
    }

    @Test
    fun isGyroscopeGroundTruthInitialBias_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.isGyroscopeGroundTruthInitialBias = true
        }
    }

    @Test
    fun isMagnetometerGroundTruthInitialHardIron_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)

        // set new value
        calibrator.isMagnetometerGroundTruthInitialHardIron = true

        // check
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
    }

    @Test
    fun isMagnetometerGroundTruthInitialHardIron_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.isMagnetometerGroundTruthInitialHardIron = true
        }
    }

    @Test
    fun accelerometerInitialMa_whenValid_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            Matrix(MA_SIZE, MA_SIZE),
            calibrator.accelerometerInitialMa)
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)

        // set new values
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()

        val ma = Matrix(MA_SIZE, MA_SIZE)
        ma.setElementAtIndex(0, initialSx)
        ma.setElementAtIndex(1, initialMyx)
        ma.setElementAtIndex(2, initialMzx)

        ma.setElementAtIndex(3, initialMxy)
        ma.setElementAtIndex(4, initialSy)
        ma.setElementAtIndex(5, initialMzy)

        ma.setElementAtIndex(6, initialMxz)
        ma.setElementAtIndex(7, initialMyz)
        ma.setElementAtIndex(8, initialSz)

        calibrator.accelerometerInitialMa = ma

        // check
        assertEquals(ma, calibrator.accelerometerInitialMa)
        assertEquals(initialSx, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(initialSy, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(initialSz, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(initialMxy, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(initialMxz, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(initialMyx, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(initialMyz, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(initialMzx, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(initialMzy, calibrator.accelerometerInitialMzy, 0.0)
    }

    @Test
    fun accelerometerInitialMa_whenInvalidRowsSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val ma = Matrix(1, MA_SIZE)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerInitialMa = ma
        }
    }

    @Test
    fun accelerometerInitialMa_whenInvalidColumnsSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val ma = Matrix(MA_SIZE, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerInitialMa = ma
        }
    }

    @Test
    fun accelerometerInitialMa_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMa = Matrix(MA_SIZE, MA_SIZE)
        }
    }

    @Test
    fun getAccelerometerInitialMa_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        // check
        val ma = Matrix(MA_SIZE, MA_SIZE)
        calibrator.getAccelerometerInitialMa(ma)

        // check
        assertEquals(initialSx, ma.getElementAtIndex(0), 0.0)
        assertEquals(initialMyx, ma.getElementAtIndex(1), 0.0)
        assertEquals(initialMzx, ma.getElementAtIndex(2), 0.0)

        assertEquals(initialMxy, ma.getElementAtIndex(3), 0.0)
        assertEquals(initialSy, ma.getElementAtIndex(4), 0.0)
        assertEquals(initialMzy, ma.getElementAtIndex(5), 0.0)

        assertEquals(initialMxz, ma.getElementAtIndex(6), 0.0)
        assertEquals(initialMyz, ma.getElementAtIndex(7), 0.0)
        assertEquals(initialSz, ma.getElementAtIndex(8), 0.0)
    }

    @Test
    fun getAccelerometerInitialMa_whenInvalidRowSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val ma = Matrix(1, MA_SIZE)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getAccelerometerInitialMa(ma)
        }
    }

    @Test
    fun getAccelerometerInitialMa_whenInvalidColumnSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val ma = Matrix(MA_SIZE, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getAccelerometerInitialMa(ma)
        }
    }

    @Test
    fun accelerometerInitialSx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        calibrator.accelerometerInitialSx = initialSx

        // check
        assertEquals(initialSx, calibrator.accelerometerInitialSx, 0.0)
    }

    @Test
    fun accelerometerInitialSx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialSx = 0.0
        }
    }

    @Test
    fun accelerometerInitialSy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSy = randomizer.nextDouble()
        calibrator.accelerometerInitialSy = initialSy

        // check
        assertEquals(initialSy, calibrator.accelerometerInitialSy, 0.0)
    }

    @Test
    fun accelerometerInitialSy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialSy = 0.0
        }
    }

    @Test
    fun accelerometerInitialSz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSz = randomizer.nextDouble()
        calibrator.accelerometerInitialSz = initialSz

        // check
        assertEquals(initialSz, calibrator.accelerometerInitialSz, 0.0)
    }

    @Test
    fun accelerometerInitialSz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialSz = 0.0
        }
    }

    @Test
    fun accelerometerInitialMxy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMxy = randomizer.nextDouble()
        calibrator.accelerometerInitialMxy = initialMxy

        // check
        assertEquals(initialMxy, calibrator.accelerometerInitialMxy, 0.0)
    }

    @Test
    fun accelerometerInitialMxy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMxy = 0.0
        }
    }

    @Test
    fun accelerometerInitialMxz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMxz = randomizer.nextDouble()
        calibrator.accelerometerInitialMxz = initialMxz

        // check
        assertEquals(initialMxz, calibrator.accelerometerInitialMxz, 0.0)
    }

    @Test
    fun accelerometerInitialMxz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMxz = 0.0
        }
    }

    @Test
    fun accelerometerInitialMyx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMyx = randomizer.nextDouble()
        calibrator.accelerometerInitialMyx = initialMyx

        // check
        assertEquals(initialMyx, calibrator.accelerometerInitialMyx, 0.0)
    }

    @Test
    fun accelerometerInitialMyx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMyx = 0.0
        }
    }

    @Test
    fun accelerometerInitialMyz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMyz = randomizer.nextDouble()
        calibrator.accelerometerInitialMyz = initialMyz

        // check
        assertEquals(initialMyz, calibrator.accelerometerInitialMyz, 0.0)
    }

    @Test
    fun accelerometerInitialMyz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMyz = 0.0
        }
    }

    @Test
    fun accelerometerInitialMzx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMzx = randomizer.nextDouble()
        calibrator.accelerometerInitialMzx = initialMzx

        // check
        assertEquals(initialMzx, calibrator.accelerometerInitialMzx, 0.0)
    }

    @Test
    fun accelerometerInitialMzx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMzx = 0.0
        }
    }

    @Test
    fun accelerometerInitialMzy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMzy = randomizer.nextDouble()
        calibrator.accelerometerInitialMzy = initialMzy

        // check
        assertEquals(initialMzy, calibrator.accelerometerInitialMzy, 0.0)
    }

    @Test
    fun accelerometerInitialMzy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerInitialMzy = 0.0
        }
    }

    @Test
    fun setAccelerometerInitialScalingFactors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactors(initialSx, initialSy, initialSz)

        // check
        assertEquals(initialSx, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(initialSy, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(initialSz, calibrator.accelerometerInitialSz, 0.0)
    }

    @Test
    fun setAccelerometerInitialScalingFactors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setAccelerometerInitialScalingFactors(initialSx, initialSy, initialSz)
        }
    }

    @Test
    fun setAccelerometerInitialCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialCrossCouplingErrors(
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        // check
        assertEquals(initialMxy, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(initialMxz, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(initialMyx, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(initialMyz, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(initialMzx, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(initialMzy, calibrator.accelerometerInitialMzy, 0.0)

        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)
    }

    @Test
    fun setAccelerometerInitialCrossCouplingErrors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        val randomizer = UniformRandomizer()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setAccelerometerInitialCrossCouplingErrors(
                initialMxy,
                initialMxz,
                initialMyx,
                initialMyz,
                initialMzx,
                initialMzy
            )
        }
    }

    @Test
    fun setAccelerometerInitialScalingFactorsAndCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.accelerometerInitialMzy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        // check
        assertEquals(initialSx, calibrator.accelerometerInitialSx, 0.0)
        assertEquals(initialSy, calibrator.accelerometerInitialSy, 0.0)
        assertEquals(initialSz, calibrator.accelerometerInitialSz, 0.0)
        assertEquals(initialMxy, calibrator.accelerometerInitialMxy, 0.0)
        assertEquals(initialMxz, calibrator.accelerometerInitialMxz, 0.0)
        assertEquals(initialMyx, calibrator.accelerometerInitialMyx, 0.0)
        assertEquals(initialMyz, calibrator.accelerometerInitialMyz, 0.0)
        assertEquals(initialMzx, calibrator.accelerometerInitialMzx, 0.0)
        assertEquals(initialMzy, calibrator.accelerometerInitialMzy, 0.0)
    }

    @Test
    fun setAccelerometerInitialScalingFactorsAndCrossCouplingErrors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
                initialSx,
                initialSy,
                initialSz,
                initialMxy,
                initialMxz,
                initialMyx,
                initialMyz,
                initialMzx,
                initialMzy
            )
        }
    }

    @Test
    fun gyroscopeInitialMg_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val mg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val mg2 = calibrator.gyroscopeInitialMg
        assertEquals(mg1, mg2)

        // set new value
        val mg3 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, mg3)
        calibrator.gyroscopeInitialMg = mg3

        // check
        val mg4 = calibrator.gyroscopeInitialMg
        assertEquals(mg3, mg4)
        assertEquals(mg3.getElementAt(0, 0), calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(mg3.getElementAt(1, 0), calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(mg3.getElementAt(2, 0), calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(mg3.getElementAt(0, 1), calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(mg3.getElementAt(1, 1), calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(mg3.getElementAt(2, 1), calibrator.gyroscopeInitialMzy, 0.0)
        assertEquals(mg3.getElementAt(0, 2), calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(mg3.getElementAt(1, 2), calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(mg3.getElementAt(2, 2), calibrator.gyroscopeInitialSz, 0.0)
    }

    @Test
    fun gyroscopeInitialMg_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        val mg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMg = mg1
        }
    }

    @Test
    fun gyroscopeInitialMg_whenInvalidRows_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mg1 = Matrix(1, BodyKinematics.COMPONENTS)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeInitialMg = mg1
        }
    }

    @Test
    fun gyroscopeInitialMg_whenInvalidColumns_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mg1 = Matrix(BodyKinematics.COMPONENTS, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeInitialMg = mg1
        }
    }

    @Test
    fun getGyroscopeInitialMg_whenValid_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val mg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val mg2 = calibrator.gyroscopeInitialMg
        assertEquals(mg1, mg2)

        // set new value
        val mg3 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, mg3)
        calibrator.gyroscopeInitialMg = mg3

        // check
        val mg4 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        calibrator.getGyroscopeInitialMg(mg4)
        assertEquals(mg3, mg4)
    }

    @Test
    fun getGyroscopeInitialMg_whenInvalidRows_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val mg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, mg1)
        calibrator.gyroscopeInitialMg = mg1

        // get
        val mg2 = Matrix(1, BodyKinematics.COMPONENTS)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getGyroscopeInitialMg(mg2)
        }
    }

    @Test
    fun getGyroscopeInitialMg_whenInvalidColumns_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val mg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, mg1)
        calibrator.gyroscopeInitialMg = mg1

        // get
        val mg2 = Matrix(BodyKinematics.COMPONENTS, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getGyroscopeInitialMg(mg2)
        }
    }

    @Test
    fun gyroscopeInitialSx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        calibrator.gyroscopeInitialSx = gyroscopeInitialSx

        // check
        assertEquals(gyroscopeInitialSx, calibrator.gyroscopeInitialSx, 0.0)
    }

    @Test
    fun gyroscopeInitialSx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialSx = gyroscopeInitialSx
        }
    }

    @Test
    fun gyroscopeInitialSy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSy = randomizer.nextDouble()
        calibrator.gyroscopeInitialSy = gyroscopeInitialSy

        // check
        assertEquals(gyroscopeInitialSy, calibrator.gyroscopeInitialSy, 0.0)
    }

    @Test
    fun gyroscopeInitialSy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialSy = gyroscopeInitialSy
        }
    }

    @Test
    fun gyroscopeInitialSz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSz = randomizer.nextDouble()
        calibrator.gyroscopeInitialSz = gyroscopeInitialSz

        // check
        assertEquals(gyroscopeInitialSz, calibrator.gyroscopeInitialSz, 0.0)
    }

    @Test
    fun gyroscopeInitialSz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialSz = gyroscopeInitialSz
        }
    }

    @Test
    fun gyroscopeInitialMxy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMxy, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        calibrator.gyroscopeInitialMxy = gyroscopeInitialMxy

        // check
        assertEquals(gyroscopeInitialMxy, calibrator.gyroscopeInitialMxy, 0.0)
    }

    @Test
    fun gyroscopeInitialMxy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMxy = gyroscopeInitialMxy
        }
    }

    @Test
    fun gyroscopeInitialMxz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMxz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        calibrator.gyroscopeInitialMxz = gyroscopeInitialMxz

        // check
        assertEquals(gyroscopeInitialMxz, calibrator.gyroscopeInitialMxz, 0.0)
    }

    @Test
    fun gyroscopeInitialMxz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMxz = gyroscopeInitialMxz
        }
    }

    @Test
    fun gyroscopeInitialMyx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMyx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        calibrator.gyroscopeInitialMyx = gyroscopeInitialMyx

        // check
        assertEquals(gyroscopeInitialMyx, calibrator.gyroscopeInitialMyx, 0.0)
    }

    @Test
    fun gyroscopeInitialMyx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMyx = gyroscopeInitialMyx
        }
    }

    @Test
    fun gyroscopeInitialMyz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMyz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        calibrator.gyroscopeInitialMyz = gyroscopeInitialMyz

        // check
        assertEquals(gyroscopeInitialMyz, calibrator.gyroscopeInitialMyz, 0.0)
    }

    @Test
    fun gyroscopeInitialMyz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMyz = gyroscopeInitialMyz
        }
    }

    @Test
    fun gyroscopeInitialMzx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMzx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        calibrator.gyroscopeInitialMzx = gyroscopeInitialMzx

        // check
        assertEquals(gyroscopeInitialMzx, calibrator.gyroscopeInitialMzx, 0.0)
    }

    @Test
    fun gyroscopeInitialMzx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMzx = gyroscopeInitialMzx
        }
    }

    @Test
    fun gyroscopeInitialMzy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.gyroscopeInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        calibrator.gyroscopeInitialMzy = gyroscopeInitialMzy

        // check
        assertEquals(gyroscopeInitialMzy, calibrator.gyroscopeInitialMzy, 0.0)
    }

    @Test
    fun gyroscopeInitialMzy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialMzy = gyroscopeInitialMzy
        }
    }

    @Test
    fun setGyroscopeInitialScalingFactors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSz, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        val gyroscopeInitialSy = randomizer.nextDouble()
        val gyroscopeInitialSz = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactors(
            gyroscopeInitialSx,
            gyroscopeInitialSy,
            gyroscopeInitialSz
        )

        // check
        assertEquals(gyroscopeInitialSx, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(gyroscopeInitialSy, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(gyroscopeInitialSz, calibrator.gyroscopeInitialSz, 0.0)
    }

    @Test
    fun setGyroscopeInitialScalingFactors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        val gyroscopeInitialSy = randomizer.nextDouble()
        val gyroscopeInitialSz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setGyroscopeInitialScalingFactors(
                gyroscopeInitialSx,
                gyroscopeInitialSy,
                gyroscopeInitialSz
            )
        }
    }

    @Test
    fun setGyroscopeInitialCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialCrossCouplingErrors(
            gyroscopeInitialMxy,
            gyroscopeInitialMxz,
            gyroscopeInitialMyx,
            gyroscopeInitialMyz,
            gyroscopeInitialMzx,
            gyroscopeInitialMzy
        )

        // check
        assertEquals(gyroscopeInitialMxy, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(gyroscopeInitialMxz, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(gyroscopeInitialMyx, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(gyroscopeInitialMyz, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(gyroscopeInitialMzx, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(gyroscopeInitialMzy, calibrator.gyroscopeInitialMzy, 0.0)
    }

    @Test
    fun setGyroscopeInitialCrossCouplingErrors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setGyroscopeInitialCrossCouplingErrors(
                gyroscopeInitialMxy,
                gyroscopeInitialMxz,
                gyroscopeInitialMyx,
                gyroscopeInitialMyz,
                gyroscopeInitialMzx,
                gyroscopeInitialMzy
            )
        }
    }

    @Test
    fun setGyroscopeInitialScalingFactorsAndCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialSz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(0.0, calibrator.gyroscopeInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        val gyroscopeInitialSy = randomizer.nextDouble()
        val gyroscopeInitialSz = randomizer.nextDouble()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            gyroscopeInitialSx,
            gyroscopeInitialSy,
            gyroscopeInitialSz,
            gyroscopeInitialMxy,
            gyroscopeInitialMxz,
            gyroscopeInitialMyx,
            gyroscopeInitialMyz,
            gyroscopeInitialMzx,
            gyroscopeInitialMzy
        )

        // check
        assertEquals(gyroscopeInitialSx, calibrator.gyroscopeInitialSx, 0.0)
        assertEquals(gyroscopeInitialSy, calibrator.gyroscopeInitialSy, 0.0)
        assertEquals(gyroscopeInitialSz, calibrator.gyroscopeInitialSz, 0.0)
        assertEquals(gyroscopeInitialMxy, calibrator.gyroscopeInitialMxy, 0.0)
        assertEquals(gyroscopeInitialMxz, calibrator.gyroscopeInitialMxz, 0.0)
        assertEquals(gyroscopeInitialMyx, calibrator.gyroscopeInitialMyx, 0.0)
        assertEquals(gyroscopeInitialMyz, calibrator.gyroscopeInitialMyz, 0.0)
        assertEquals(gyroscopeInitialMzx, calibrator.gyroscopeInitialMzx, 0.0)
        assertEquals(gyroscopeInitialMzy, calibrator.gyroscopeInitialMzy, 0.0)
    }

    @Test
    fun setGyroscopeInitialScalingFactorsAndCrossCouplingErrors_whenRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val gyroscopeInitialSx = randomizer.nextDouble()
        val gyroscopeInitialSy = randomizer.nextDouble()
        val gyroscopeInitialSz = randomizer.nextDouble()
        val gyroscopeInitialMxy = randomizer.nextDouble()
        val gyroscopeInitialMxz = randomizer.nextDouble()
        val gyroscopeInitialMyx = randomizer.nextDouble()
        val gyroscopeInitialMyz = randomizer.nextDouble()
        val gyroscopeInitialMzx = randomizer.nextDouble()
        val gyroscopeInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
                gyroscopeInitialSx,
                gyroscopeInitialSy,
                gyroscopeInitialSz,
                gyroscopeInitialMxy,
                gyroscopeInitialMxz,
                gyroscopeInitialMyx,
                gyroscopeInitialMyz,
                gyroscopeInitialMzx,
                gyroscopeInitialMzy
            )
        }
    }

    @Test
    fun gyroscopeInitialGg_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val gg1 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val gg2 = calibrator.gyroscopeInitialGg
        assertEquals(gg1, gg2)

        // set new value
        val gg3 = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg3)
        calibrator.gyroscopeInitialGg = gg3

        // check
        val gg4 = calibrator.gyroscopeInitialGg
        assertEquals(gg3, gg4)
    }

    @Test
    fun gyroscopeInitialGg_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeInitialGg = gg
        }
    }

    @Test
    fun gyroscopeInitialGg_whenInvalidRows_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val gg = Matrix(1, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeInitialGg = gg
        }
    }

    @Test
    fun gyroscopeInitialGg_whenInvalidColumns_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val gg = Matrix(BodyKinematics.COMPONENTS, 1)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeInitialGg = gg
        }
    }

    @Test
    fun magnetometerInitialMm_whenValid_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            Matrix(MM_SIZE, MM_SIZE),
            calibrator.magnetometerInitialMm
        )
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()

        val mm = Matrix(MM_SIZE, MM_SIZE)
        mm.setElementAtIndex(0, initialSx)
        mm.setElementAtIndex(1, initialMyx)
        mm.setElementAtIndex(2, initialMzx)

        mm.setElementAtIndex(3, initialMxy)
        mm.setElementAtIndex(4, initialSy)
        mm.setElementAtIndex(5, initialMzy)

        mm.setElementAtIndex(6, initialMxz)
        mm.setElementAtIndex(7, initialMyz)
        mm.setElementAtIndex(8, initialSz)

        calibrator.magnetometerInitialMm = mm

        // check
        assertEquals(mm, calibrator.magnetometerInitialMm)
        assertEquals(initialSx, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(initialSy, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(initialSz, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(initialMxy, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(initialMxz, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(initialMyx, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(initialMyz, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(initialMzx, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(initialMzy, calibrator.magnetometerInitialMzy, 0.0)
    }

    @Test
    fun magnetometerInitialMm_whenInvalidRowSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mm = Matrix(1, MM_SIZE)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerInitialMm = mm
        }
    }

    @Test
    fun magnetometerInitialMm_whenInvalidColumnsSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mm = Matrix(MM_SIZE, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerInitialMm = mm
        }
    }

    @Test
    fun magnetometerInitialMm_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMm = Matrix(MM_SIZE, MM_SIZE)
        }
    }

    @Test
    fun getMagnetometerInitialMm_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // set new value
        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        // check
        val mm = Matrix(MM_SIZE, MM_SIZE)
        calibrator.getMagnetometerInitialMm(mm)

        // check
        assertEquals(initialSx, mm.getElementAtIndex(0), 0.0)
        assertEquals(initialMyx, mm.getElementAtIndex(1), 0.0)
        assertEquals(initialMzx, mm.getElementAtIndex(2), 0.0)

        assertEquals(initialMxy, mm.getElementAtIndex(3), 0.0)
        assertEquals(initialSy, mm.getElementAtIndex(4), 0.0)
        assertEquals(initialMzy, mm.getElementAtIndex(5), 0.0)

        assertEquals(initialMxz, mm.getElementAtIndex(6), 0.0)
        assertEquals(initialMyz, mm.getElementAtIndex(7), 0.0)
        assertEquals(initialSz, mm.getElementAtIndex(8), 0.0)
    }

    @Test
    fun getMagnetometerInitialMm_whenInvalidRowSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mm = Matrix(1, MM_SIZE)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getMagnetometerInitialMm(mm)
        }
    }

    @Test
    fun getMagnetometerInitialMm_whenInvalidColumnSize_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val mm = Matrix(MM_SIZE, 1)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.getMagnetometerInitialMm(mm)
        }
    }

    @Test
    fun magnetometerInitialSx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        calibrator.magnetometerInitialSx = magnetometerInitialSx

        // check
        assertEquals(magnetometerInitialSx, calibrator.magnetometerInitialSx, 0.0)
    }

    @Test
    fun magnetometerInitialSx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialSx = magnetometerInitialSx
        }
    }

    @Test
    fun magnetometerInitialSy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSy = randomizer.nextDouble()
        calibrator.magnetometerInitialSy = magnetometerInitialSy

        // check
        assertEquals(magnetometerInitialSy, calibrator.magnetometerInitialSy, 0.0)
    }

    @Test
    fun magnetometerInitialSy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialSy = magnetometerInitialSy
        }
    }

    @Test
    fun magnetometerInitialSz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSz = randomizer.nextDouble()
        calibrator.magnetometerInitialSz = magnetometerInitialSz

        // check
        assertEquals(magnetometerInitialSz, calibrator.magnetometerInitialSz, 0.0)
    }

    @Test
    fun magnetometerInitialSz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialSz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialSz = magnetometerInitialSz
        }
    }

    @Test
    fun magnetometerInitialMxy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxy = randomizer.nextDouble()
        calibrator.magnetometerInitialMxy = magnetometerInitialMxy

        // check
        assertEquals(magnetometerInitialMxy, calibrator.magnetometerInitialMxy, 0.0)
    }

    @Test
    fun magnetometerInitialMxy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMxy = magnetometerInitialMxy
        }
    }

    @Test
    fun magnetometerInitialMxz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxz = randomizer.nextDouble()
        calibrator.magnetometerInitialMxz = magnetometerInitialMxz

        // check
        assertEquals(magnetometerInitialMxz, calibrator.magnetometerInitialMxz, 0.0)
    }

    @Test
    fun magnetometerInitialMxz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMxz = magnetometerInitialMxz
        }
    }

    @Test
    fun magnetometerInitialMyx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMyx = randomizer.nextDouble()
        calibrator.magnetometerInitialMyx = magnetometerInitialMyx

        // check
        assertEquals(magnetometerInitialMyx, calibrator.magnetometerInitialMyx, 0.0)
    }

    @Test
    fun magnetometerInitialMyx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMyx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMyx = magnetometerInitialMyx
        }
    }

    @Test
    fun magnetometerInitialMyz_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMyz = randomizer.nextDouble()
        calibrator.magnetometerInitialMyz = magnetometerInitialMyz

        // check
        assertEquals(magnetometerInitialMyz, calibrator.magnetometerInitialMyz, 0.0)
    }

    @Test
    fun magnetometerInitialMyz_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMyz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMyz = magnetometerInitialMyz
        }
    }

    @Test
    fun magnetometerInitialMzx_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMzx = randomizer.nextDouble()
        calibrator.magnetometerInitialMzx = magnetometerInitialMzx

        // check
        assertEquals(magnetometerInitialMzx, calibrator.magnetometerInitialMzx, 0.0)
    }

    @Test
    fun magnetometerInitialMzx_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMzx = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMzx = magnetometerInitialMzx
        }
    }

    @Test
    fun magnetometerInitialMzy_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMzy = randomizer.nextDouble()
        calibrator.magnetometerInitialMzy = magnetometerInitialMzy

        // check
        assertEquals(magnetometerInitialMzy, calibrator.magnetometerInitialMzy, 0.0)
    }

    @Test
    fun magnetometerInitialMzy_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        val randomizer = UniformRandomizer()
        val magnetometerInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerInitialMzy = magnetometerInitialMzy
        }
    }

    @Test
    fun setMagnetometerInitialScalingFactors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        val magnetometerInitialSy = randomizer.nextDouble()
        val magnetometerInitialSz = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactors(
            magnetometerInitialSx,
            magnetometerInitialSy,
            magnetometerInitialSz
        )

        // check
        assertEquals(magnetometerInitialSx, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(magnetometerInitialSy, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(magnetometerInitialSz, calibrator.magnetometerInitialSz, 0.0)
    }

    @Test
    fun setMagnetometerInitialScalingFactors_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        val magnetometerInitialSy = randomizer.nextDouble()
        val magnetometerInitialSz = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setMagnetometerInitialScalingFactors(
                magnetometerInitialSx,
                magnetometerInitialSy,
                magnetometerInitialSz
            )
        }
    }

    @Test
    fun setMagnetometerInitialCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxy = randomizer.nextDouble()
        val magnetometerInitialMxz = randomizer.nextDouble()
        val magnetometerInitialMyx = randomizer.nextDouble()
        val magnetometerInitialMyz = randomizer.nextDouble()
        val magnetometerInitialMzx = randomizer.nextDouble()
        val magnetometerInitialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialCrossCouplingErrors(
            magnetometerInitialMxy,
            magnetometerInitialMxz,
            magnetometerInitialMyx,
            magnetometerInitialMyz,
            magnetometerInitialMzx,
            magnetometerInitialMzy
        )

        // check
        assertEquals(magnetometerInitialMxy, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(magnetometerInitialMxz, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(magnetometerInitialMyx, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(magnetometerInitialMyz, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(magnetometerInitialMzx, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(magnetometerInitialMzy, calibrator.magnetometerInitialMzy, 0.0)
    }

    @Test
    fun setMagnetometerInitialCrossCouplingErrors_whenRunning_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialMxy = randomizer.nextDouble()
        val magnetometerInitialMxz = randomizer.nextDouble()
        val magnetometerInitialMyx = randomizer.nextDouble()
        val magnetometerInitialMyz = randomizer.nextDouble()
        val magnetometerInitialMzx = randomizer.nextDouble()
        val magnetometerInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setMagnetometerInitialCrossCouplingErrors(
                magnetometerInitialMxy,
                magnetometerInitialMxz,
                magnetometerInitialMyx,
                magnetometerInitialMyz,
                magnetometerInitialMzx,
                magnetometerInitialMzy
            )
        }
    }

    @Test
    fun setMagnetometerInitialScalingFactorsAndCrossCouplingErrors_whenNotRunning_setsExpectedValues() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertEquals(0.0, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(0.0, calibrator.magnetometerInitialMzy, 0.0)
        assertFalse(calibrator.running)

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        val magnetometerInitialSy = randomizer.nextDouble()
        val magnetometerInitialSz = randomizer.nextDouble()
        val magnetometerInitialMxy = randomizer.nextDouble()
        val magnetometerInitialMxz = randomizer.nextDouble()
        val magnetometerInitialMyx = randomizer.nextDouble()
        val magnetometerInitialMyz = randomizer.nextDouble()
        val magnetometerInitialMzx = randomizer.nextDouble()
        val magnetometerInitialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            magnetometerInitialSx,
            magnetometerInitialSy,
            magnetometerInitialSz,
            magnetometerInitialMxy,
            magnetometerInitialMxz,
            magnetometerInitialMyx,
            magnetometerInitialMyz,
            magnetometerInitialMzx,
            magnetometerInitialMzy
        )

        // check
        assertEquals(magnetometerInitialSx, calibrator.magnetometerInitialSx, 0.0)
        assertEquals(magnetometerInitialSy, calibrator.magnetometerInitialSy, 0.0)
        assertEquals(magnetometerInitialSz, calibrator.magnetometerInitialSz, 0.0)
        assertEquals(magnetometerInitialMxy, calibrator.magnetometerInitialMxy, 0.0)
        assertEquals(magnetometerInitialMxz, calibrator.magnetometerInitialMxz, 0.0)
        assertEquals(magnetometerInitialMyx, calibrator.magnetometerInitialMyx, 0.0)
        assertEquals(magnetometerInitialMyz, calibrator.magnetometerInitialMyz, 0.0)
        assertEquals(magnetometerInitialMzx, calibrator.magnetometerInitialMzx, 0.0)
        assertEquals(magnetometerInitialMzy, calibrator.magnetometerInitialMzy, 0.0)
    }

    @Test
    fun setMagnetometerInitialScalingFactorsAndCrossCouplingErrors_whenRunning_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new values
        val randomizer = UniformRandomizer()
        val magnetometerInitialSx = randomizer.nextDouble()
        val magnetometerInitialSy = randomizer.nextDouble()
        val magnetometerInitialSz = randomizer.nextDouble()
        val magnetometerInitialMxy = randomizer.nextDouble()
        val magnetometerInitialMxz = randomizer.nextDouble()
        val magnetometerInitialMyx = randomizer.nextDouble()
        val magnetometerInitialMyz = randomizer.nextDouble()
        val magnetometerInitialMzx = randomizer.nextDouble()
        val magnetometerInitialMzy = randomizer.nextDouble()
        assertThrows(IllegalStateException::class.java) {
            calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
                magnetometerInitialSx,
                magnetometerInitialSy,
                magnetometerInitialSz,
                magnetometerInitialMxy,
                magnetometerInitialMxz,
                magnetometerInitialMyx,
                magnetometerInitialMyz,
                magnetometerInitialMzx,
                magnetometerInitialMzy
            )
        }
    }

    @Test
    fun isAccelerometerCommonAxisUsed_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertFalse(calibrator.isAccelerometerCommonAxisUsed)

        // set new value
        calibrator.isAccelerometerCommonAxisUsed = true

        // check
        assertTrue(calibrator.isAccelerometerCommonAxisUsed)
    }

    @Test
    fun isAccelerometerCommonAxisUsed_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.isAccelerometerCommonAxisUsed = true
        }
    }

    @Test
    fun isGyroscopeCommonAxisUsed_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.running)

        // set new value
        calibrator.isGyroscopeCommonAxisUsed = true

        // check
        assertTrue(calibrator.isGyroscopeCommonAxisUsed)
    }

    @Test
    fun isGyroscopeCommonAxisUsed_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        assertThrows(IllegalStateException::class.java) {
            calibrator.isGyroscopeCommonAxisUsed = true
        }
    }

    @Test
    fun isMagnetometerCommonAxisUsed_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertFalse(calibrator.isMagnetometerCommonAxisUsed)
        assertFalse(calibrator.running)

        // set new value
        calibrator.isMagnetometerCommonAxisUsed = true

        // check
        assertTrue(calibrator.isMagnetometerCommonAxisUsed)
    }

    @Test
    fun isMagnetometerCommonAxisUsed_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        assertThrows(IllegalStateException::class.java) {
            calibrator.isMagnetometerCommonAxisUsed = true
        }
    }

    @Test
    fun isGDependentCrossBiasesEstimated_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default values
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertFalse(calibrator.running)

        // set new value
        calibrator.isGDependentCrossBiasesEstimated = true

        // check
        assertTrue(calibrator.isGDependentCrossBiasesEstimated)
    }

    @Test
    fun isGDependentCrossBiasesEstimated_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        // set new value
        assertThrows(IllegalStateException::class.java) {
            calibrator.isGDependentCrossBiasesEstimated = true
        }
    }

    @Test
    fun minimumRequiredAccelerometerMeasurements_whenCommonAxisAndKnownBias_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isAccelerometerCommonAxisUsed = true
        calibrator.isAccelerometerGroundTruthInitialBias = true

        // check
        assertTrue(calibrator.isAccelerometerCommonAxisUsed)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertEquals(7, calibrator.minimumRequiredAccelerometerMeasurements)
    }

    @Test
    fun minimumRequiredAccelerometerMeasurements_whenCommonAxisAndUnknownBias_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isAccelerometerCommonAxisUsed = true
        calibrator.isAccelerometerGroundTruthInitialBias = false

        // check
        assertTrue(calibrator.isAccelerometerCommonAxisUsed)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertEquals(10, calibrator.minimumRequiredAccelerometerMeasurements)
    }

    @Test
    fun minimumRequiredAccelerometerMeasurements_whenNotCommonAxisAndKnownBias_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isAccelerometerCommonAxisUsed = false
        calibrator.isAccelerometerGroundTruthInitialBias = true

        // check
        assertFalse(calibrator.isAccelerometerCommonAxisUsed)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertEquals(10, calibrator.minimumRequiredAccelerometerMeasurements)
    }

    @Test
    fun minimumRequiredAccelerometerMeasurements_whenNotCommonAxisAndUnknownBias_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isAccelerometerCommonAxisUsed = false
        calibrator.isAccelerometerGroundTruthInitialBias = false

        // check
        assertFalse(calibrator.isAccelerometerCommonAxisUsed)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertEquals(13, calibrator.minimumRequiredAccelerometerMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenGroundTruthInitialBiasCommonAxisAndCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = true
        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true

        // check
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertTrue(calibrator.isGyroscopeCommonAxisUsed)
        assertTrue(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(16, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenGroundTruthInitialBiasCommonAxisAndNoCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = true
        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = false

        // check
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertTrue(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(7, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenGroundTruthInitialBiasNoCommonAxisAndCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = true
        calibrator.isGyroscopeCommonAxisUsed = false
        calibrator.isGDependentCrossBiasesEstimated = true

        // check
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertTrue(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(19, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenGroundTruthInitialBiasNoCommonAxisAndNoCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = true
        calibrator.isGyroscopeCommonAxisUsed = false
        calibrator.isGDependentCrossBiasesEstimated = false

        // check
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(10, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenNoGroundTruthInitialBiasCommonAxisAndCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = false
        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true

        // check
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertTrue(calibrator.isGyroscopeCommonAxisUsed)
        assertTrue(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(19, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenNoGroundTruthInitialBiasCommonAxisAndNoCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = false
        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = false

        // check
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertTrue(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(10, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenNoGroundTruthInitialBiasNoCommonAxisAndCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = false
        calibrator.isGyroscopeCommonAxisUsed = false
        calibrator.isGDependentCrossBiasesEstimated = true

        // check
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertTrue(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(22, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredGyroscopeMeasurements_whenNoGroundTruthInitialBiasNoCommonAxisAndNoCrossBiases_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isGyroscopeGroundTruthInitialBias = false
        calibrator.isGyroscopeCommonAxisUsed = false
        calibrator.isGDependentCrossBiasesEstimated = false

        // check
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertFalse(calibrator.isGyroscopeCommonAxisUsed)
        assertFalse(calibrator.isGDependentCrossBiasesEstimated)
        assertEquals(13, calibrator.minimumRequiredGyroscopeMeasurements)
    }

    @Test
    fun minimumRequiredMagnetometerMeasurements_whenCommonAxisAndKnownHardIron_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isMagnetometerCommonAxisUsed = true
        calibrator.isMagnetometerGroundTruthInitialHardIron = true

        // check
        assertTrue(calibrator.isMagnetometerCommonAxisUsed)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(7, calibrator.minimumRequiredMagnetometerMeasurements)
    }

    @Test
    fun minimumRequiredMagnetometerMeasurements_whenCommonAxisAndUnknownHardIron_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isMagnetometerCommonAxisUsed = true
        calibrator.isMagnetometerGroundTruthInitialHardIron = false

        // check
        assertTrue(calibrator.isMagnetometerCommonAxisUsed)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(10, calibrator.minimumRequiredMagnetometerMeasurements)
    }

    @Test
    fun minimumRequiredMagnetometerMeasurements_whenNotCommonAxisAndKnownHardIron_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isMagnetometerCommonAxisUsed = false
        calibrator.isMagnetometerGroundTruthInitialHardIron = true

        // check
        assertFalse(calibrator.isMagnetometerCommonAxisUsed)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(10, calibrator.minimumRequiredMagnetometerMeasurements)
    }

    @Test
    fun minimumRequiredMagnetometerMeasurements_whenNotCommonAxisAndUnknownHardIron_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        calibrator.isMagnetometerCommonAxisUsed = false
        calibrator.isMagnetometerGroundTruthInitialHardIron = false

        // check
        assertFalse(calibrator.isMagnetometerCommonAxisUsed)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(13, calibrator.minimumRequiredMagnetometerMeasurements)
    }

    @Test
    fun averageGravityNorm_whenGravityNormEstimated_getsEstimatorAverageNorm() {
        val location = getLocation()
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        every { gravityNormEstimatorSpy.averageNorm }.returns(gravityNorm)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        assertEquals(gravityNorm, calibrator.averageGravityNorm)
        verify(exactly = 1) { gravityNormEstimatorSpy.averageNorm }
    }

    @Test
    fun averageGravityNorm_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)

        assertNull(calibrator.averageGravityNorm)
    }

    @Test
    fun averageGravityNormAsMeasurement_whenGravityNormEstimated_getsEstimatorAverageNorm() {
        val location = getLocation()
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        val acceleration = Acceleration(gravityNorm, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { gravityNormEstimatorSpy.averageNormAsMeasurement }.returns(acceleration)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        assertSame(acceleration, gravityNormEstimatorSpy.averageNormAsMeasurement)
        verify(exactly = 1) { gravityNormEstimatorSpy.averageNormAsMeasurement }
    }

    @Test
    fun averageGravityNormAsMeasurement_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)

        assertNull(calibrator.averageGravityNormAsMeasurement)
    }

    @Test
    fun getAverageGravityNormAsMeasurement_whenGravityNormEstimated_getsEstimatorAverageNorm() {
        val location = getLocation()
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        every { gravityNormEstimatorSpy.getAverageNormAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = gravityNorm
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getAverageGravityNormAsMeasurement(acceleration))
        assertEquals(gravityNorm, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
        verify(exactly = 1) { gravityNormEstimatorSpy.getAverageNormAsMeasurement(acceleration) }
    }

    @Test
    fun getAverageGravityNormAsMeasurement_whenGravityNormNotEstimated_returnsFalse() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAverageGravityNormAsMeasurement(acceleration))
        assertEquals(0.0, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun gravityNormVariance_whenGravityNormEstimated_getsEstimatorVariance() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val gravityNormVariance = randomizer.nextDouble()
        every { gravityNormEstimatorSpy.normVariance }.returns(gravityNormVariance)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val result = calibrator.gravityNormVariance
        requireNotNull(result)
        assertEquals(gravityNormVariance, result, 0.0)
        verify(exactly = 1) { gravityNormEstimatorSpy.normVariance }
    }

    @Test
    fun gravityNormVariance_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)
        assertNull(calibrator.gravityNormVariance)
    }

    @Test
    fun gravityNormStandardDeviation_whenGravityNormEstimated_getsEstimatorStandardDeviation() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val gravityNormStandardDeviation = randomizer.nextDouble()
        every { gravityNormEstimatorSpy.normStandardDeviation }.returns(gravityNormStandardDeviation)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val result = calibrator.gravityNormStandardDeviation
        requireNotNull(result)
        assertEquals(gravityNormStandardDeviation, result, 0.0)
        verify(exactly = 1) { gravityNormEstimatorSpy.normStandardDeviation }
    }

    @Test
    fun gravityNormStandardDeviation_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)
        assertNull(calibrator.gravityNormStandardDeviation)
    }

    @Test
    fun gravityNormStandardDeviationAsMeasurement_whenGravityNormEstimated_getsEstimatorStandardDeviation() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val gravityNormStandardDeviation = randomizer.nextDouble()
        val acceleration =
            Acceleration(gravityNormStandardDeviation, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { gravityNormEstimatorSpy.normStandardDeviationAsMeasurement }.returns(acceleration)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val result = calibrator.gravityNormStandardDeviationAsMeasurement
        assertSame(acceleration, result)
        verify(exactly = 1) { gravityNormEstimatorSpy.normStandardDeviationAsMeasurement }
    }

    @Test
    fun gravityNormStandardDeviationMeasurement_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)
        assertNull(calibrator.gravityNormStandardDeviationAsMeasurement)
    }

    @Test
    fun getGravityNormStandardDeviationAsMeasurement_whenGravityNormEstimated_getsEstimatorStandardDeviation() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val value = randomizer.nextDouble()
        every { gravityNormEstimatorSpy.getNormStandardDeviationAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = value
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getGravityNormStandardDeviationAsMeasurement(acceleration))
        assertEquals(value, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
        verify(exactly = 1) {
            gravityNormEstimatorSpy.getNormStandardDeviationAsMeasurement(
                acceleration
            )
        }
    }

    @Test
    fun getGravityNormStandardDeviationAsMeasurement_whenGravityNormNotEstimated_returnsFalse() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getGravityNormStandardDeviationAsMeasurement(acceleration))
    }

    @Test
    fun gravityPsd_whenGravityNormEstimated_getsEstimatorPsd() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val gravityPsd = randomizer.nextDouble()
        every { gravityNormEstimatorSpy.psd }.returns(gravityPsd)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        assertEquals(gravityPsd, calibrator.gravityPsd)
        verify(exactly = 1) { gravityNormEstimatorSpy.psd }
    }

    @Test
    fun gravityPsd_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)

        assertNull(calibrator.gravityPsd)
    }

    @Test
    fun gravityRootPsd_whenGravityNormEstimated_getsEstimatorRootPsd() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        val randomizer = UniformRandomizer()
        val gravityRootPsd = randomizer.nextDouble()
        every { gravityNormEstimatorSpy.rootPsd }.returns(gravityRootPsd)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        assertEquals(gravityRootPsd, calibrator.gravityRootPsd)
        verify(exactly = 1) { gravityNormEstimatorSpy.rootPsd }
    }

    @Test
    fun gravityRootPsd_whenGravityNormNotEstimated_returnsNull() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.isGravityNormEstimated)
        assertNull(calibrator.gravityRootPsd)
    }

    @Test
    fun accelerometerRobustMethod_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerRobustMethod)

        // set new value
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC

        // check
        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
    }

    @Test
    fun accelerometerRobustMethod_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        }
    }

    @Test
    fun accelerometerRobustConfidence_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.accelerometerRobustConfidence,
            0.0
        )

        // set new value
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE

        // check
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
    }

    @Test
    fun accelerometerRobustConfidence_whenInvalidLowerBound_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustConfidence = -1.0
        }
    }

    @Test
    fun accelerometerRobustConfidence_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        }
    }

    @Test
    fun accelerometerRobustMaxIterations_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.accelerometerRobustMaxIterations
        )

        // set new value
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS

        // check
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
    }

    @Test
    fun accelerometerRobustMaxIterations_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustMaxIterations = 0
        }
    }

    @Test
    fun accelerometerRobustMaxIterations_whenRunning_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        }
    }

    @Test
    fun accelerometerRobustPreliminarySubsetSize_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ACCELEROMETER_UNKNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )

        // set new value
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE

        // check
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
    }

    @Test
    fun accelerometerRobustPreliminarySubsetSize_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustPreliminarySubsetSize = 12
        }
    }

    @Test
    fun accelerometerRobustPreliminarySubsetSize_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        }
    }

    @Test
    fun accelerometerRobustThreshold_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerRobustThreshold)

        // set new value
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        // check
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        // set new value
        calibrator.accelerometerRobustThreshold = null

        // check
        assertNull(calibrator.accelerometerRobustThreshold)
    }

    @Test
    fun accelerometerRobustThreshold_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustThreshold = 0.0
        }
    }

    @Test
    fun accelerometerRobustThreshold_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD
        }
    }

    @Test
    fun accelerometerRobustThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustThresholdFactor,
            0.0
        )

        // set new value
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        // check
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
    }

    @Test
    fun accelerometerRobustThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustThresholdFactor = 0.0
        }
    }

    @Test
    fun accelerometerRobustThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        }
    }

    @Test
    fun accelerometerRobustStopThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )

        // set new value
        calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        // check
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )
    }

    @Test
    fun accelerometerRobustStopThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.accelerometerRobustStopThresholdFactor = 0.0
        }
    }

    @Test
    fun accelerometerRobustStopThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR
        }
    }

    @Test
    fun gyroscopeRobustMethod_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeRobustMethod)

        // set new value
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC

        // check
        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
    }

    @Test
    fun gyroscopeRobustMethod_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        }
    }

    @Test
    fun gyroscopeRobustConfidence_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.gyroscopeRobustConfidence,
            0.0
        )

        // set new value
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE

        // check
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
    }

    @Test
    fun gyroscopeRobustConfidence_whenInvalidLowerBound_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustConfidence = -1.0
        }
    }

    @Test
    fun gyroscopeRobustConfidence_whenInvalidUpperBound_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustConfidence = 2.0
        }
    }

    @Test
    fun gyroscopeRobustConfidence_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        }
    }

    @Test
    fun gyroscopeRobustMaxIterations_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalGyroscopeCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.gyroscopeRobustMaxIterations
        )

        // set new value
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS

        // check
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
    }

    @Test
    fun gyroscopeRobustMaxIterations_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustMaxIterations = 0
        }
    }

    @Test
    fun gyroscopeRobustMaxIterations_whenRunning_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        }
    }

    @Test
    fun gyroscopeRobustPreliminarySubsetSize_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )

        // set new value
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE

        // check
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
    }

    @Test
    fun gyroscopeRobustPreliminarySubsetSize_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustPreliminarySubsetSize = 12
        }
    }

    @Test
    fun gyroscopeRobustPreliminarySubsetSize_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        }
    }

    @Test
    fun gyroscopeRobustThreshold_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeRobustThreshold)

        // set new value
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        // check
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        // set new value
        calibrator.gyroscopeRobustThreshold = null

        // check
        assertNull(calibrator.gyroscopeRobustThreshold)
    }

    @Test
    fun gyroscopeRobustThreshold_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustThreshold = 0.0
        }
    }

    @Test
    fun gyroscopeRobustThreshold_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD
        }
    }

    @Test
    fun gyroscopeRobustThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustThresholdFactor,
            0.0
        )

        // set new value
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        // check
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
    }

    @Test
    fun gyroscopeRobustThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustThresholdFactor = 0.0
        }
    }

    @Test
    fun gyroscopeRobustThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        }
    }

    @Test
    fun gyroscopeRobustStopThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustStopThresholdFactor,
            0.0
        )

        // set new value
        calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        // check
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.gyroscopeRobustStopThresholdFactor,
            0.0
        )
    }

    @Test
    fun gyroscopeRobustStopThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.gyroscopeRobustStopThresholdFactor = 0.0
        }
    }

    @Test
    fun gyroscopeRobustStopThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR
        }
    }

    @Test
    fun magnetometerRobustMethod_whenNotRunning_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerRobustMethod)

        // set new value
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC

        // check
        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
    }

    @Test
    fun magnetometerRobustMethod_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        }
    }

    @Test
    fun magnetometerRobustConfidence_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_CONFIDENCE,
            calibrator.magnetometerRobustConfidence,
            0.0
        )

        // set new value
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE

        // check
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
    }

    @Test
    fun magnetometerRobustConfidence_whenInvalidLowerBound_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustConfidence = -1.0
        }
    }

    @Test
    fun magnetometerRobustConfidence_whenInvalidUpperBound_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustConfidence = 2.0
        }
    }

    @Test
    fun magnetometerRobustConfidence_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        }
    }

    @Test
    fun magnetometerRobustMaxIterations_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ROBUST_DEFAULT_MAX_ITERATIONS,
            calibrator.magnetometerRobustMaxIterations
        )

        // set new value
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS

        // check
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
    }

    @Test
    fun magnetometerRobustMaxIterations_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustMaxIterations = 0
        }
    }

    @Test
    fun magnetometerRobustMaxIterations_whenRunning_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        }
    }

    @Test
    fun magnetometerRobustPreliminarySubsetSize_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.ACCELEROMETER_UNKNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )

        // set new value
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE

        // check
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
    }

    @Test
    fun magnetometerRobustPreliminarySubsetSize_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustPreliminarySubsetSize = 12
        }
    }

    @Test
    fun magnetometerRobustPreliminarySubsetSize_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        }
    }

    @Test
    fun magnetometerRobustThreshold_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerRobustThreshold)

        // set new value
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        // check
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        // set new value
        calibrator.magnetometerRobustThreshold = null

        // check
        assertNull(calibrator.magnetometerRobustThreshold)
    }

    @Test
    fun magnetometerRobustThreshold_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustThreshold = 0.0
        }
    }

    @Test
    fun magnetometerRobustThreshold_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD
        }
    }

    @Test
    fun magnetometerRobustThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustThresholdFactor,
            0.0
        )

        // set new value
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        // check
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
    }

    @Test
    fun magnetometerRobustThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustThresholdFactor = 0.0
        }
    }

    @Test
    fun magnetometerRobustThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        }
    }

    @Test
    fun magnetometerRobustStopThresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertEquals(
            StaticIntervalAccelerometerCalibrator.DEFAULT_ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustStopThresholdFactor,
            0.0
        )

        // set new value
        calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        // check
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustStopThresholdFactor,
            0.0
        )
    }

    @Test
    fun magnetometerRobustStopThresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.magnetometerRobustStopThresholdFactor = 0.0
        }
    }

    @Test
    fun magnetometerRobustStopThresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR
        }
    }

    @Test
    fun windowSize_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertEquals(TriadStaticIntervalDetector.DEFAULT_WINDOW_SIZE, calibrator.windowSize)

        // set new value
        calibrator.windowSize = WINDOW_SIZE

        // check
        assertEquals(WINDOW_SIZE, calibrator.windowSize)
    }

    @Test
    fun windowSize_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.windowSize = 0
        }
    }

    @Test
    fun windowSize_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.windowSize = WINDOW_SIZE
        }
    }

    @Test
    fun initialStaticSamples_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INITIAL_STATIC_SAMPLES,
            calibrator.initialStaticSamples
        )

        // set new value
        calibrator.initialStaticSamples = INITIAL_STATIC_SAMPLES

        // check
        assertEquals(INITIAL_STATIC_SAMPLES, calibrator.initialStaticSamples)
    }

    @Test
    fun initialStaticSamples_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.initialStaticSamples = 0
        }
    }

    @Test
    fun initialStaticSamples_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.initialStaticSamples = INITIAL_STATIC_SAMPLES
        }
    }

    @Test
    fun thresholdFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_THRESHOLD_FACTOR,
            calibrator.thresholdFactor,
            0.0
        )

        // set new value
        calibrator.thresholdFactor = THRESHOLD_FACTOR

        // check
        assertEquals(THRESHOLD_FACTOR, calibrator.thresholdFactor, 0.0)
    }

    @Test
    fun thresholdFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.thresholdFactor = 0.0
        }
    }

    @Test
    fun thresholdFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.thresholdFactor = THRESHOLD_FACTOR
        }
    }

    @Test
    fun instantaneousNoiseLevelFactor_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_INSTANTANEOUS_NOISE_LEVEL_FACTOR,
            calibrator.instantaneousNoiseLevelFactor,
            0.0
        )

        // set new value
        calibrator.instantaneousNoiseLevelFactor = INSTANTANEOUS_NOISE_LEVEL_FACTOR

        // check
        assertEquals(
            INSTANTANEOUS_NOISE_LEVEL_FACTOR,
            calibrator.instantaneousNoiseLevelFactor,
            0.0
        )
    }

    @Test
    fun instantaneousNoiseLevelFactor_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.instantaneousNoiseLevelFactor = 0.0
        }
    }

    @Test
    fun instantaneousNoiseLevelFactor_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.instantaneousNoiseLevelFactor = INSTANTANEOUS_NOISE_LEVEL_FACTOR
        }
    }

    @Test
    fun baseNoiseLevelAbsoluteThreshold_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            calibrator.baseNoiseLevelAbsoluteThreshold,
            0.0
        )

        // set new value
        calibrator.baseNoiseLevelAbsoluteThreshold = BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD

        // check
        assertEquals(
            BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            calibrator.baseNoiseLevelAbsoluteThreshold,
            0.0
        )
    }

    @Test
    fun baseNoiseLevelAbsoluteThreshold_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.baseNoiseLevelAbsoluteThreshold = 0.0
        }
    }

    @Test
    fun baseNoiseLevelAbsoluteThreshold_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.baseNoiseLevelAbsoluteThreshold = BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD
        }
    }

    @Test
    fun baseNoiseLevelAbsoluteThresholdAsMeasurement_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val value1 = calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement
        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            value1.value.toDouble(),
            0.0
        )
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, value1.unit)

        // set new value
        val value2 = Acceleration(
            BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            AccelerationUnit.METERS_PER_SQUARED_SECOND
        )
        calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement = value2

        // check
        val value3 = calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement
        assertEquals(value2, value3)
    }

    @Test
    fun baseNoiseLevelAbsoluteThresholdAsMeasurement_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val value = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertThrows(IllegalArgumentException::class.java) {
            calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement = value
        }
    }

    @Test
    fun baseNoiseLevelAbsoluteThresholdAsMeasurement_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        val value = Acceleration(
            BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            AccelerationUnit.METERS_PER_SQUARED_SECOND
        )
        assertThrows(IllegalStateException::class.java) {
            calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement = value
        }
    }

    @Test
    fun getBaseNoiseLevelAbsoluteThresholdAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val value1 = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        calibrator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(value1)

        assertEquals(
            TriadStaticIntervalDetector.DEFAULT_BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            value1.value.toDouble(),
            0.0
        )
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, value1.unit)

        // set new value
        val value2 = Acceleration(
            BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD,
            AccelerationUnit.METERS_PER_SQUARED_SECOND
        )
        calibrator.baseNoiseLevelAbsoluteThresholdAsMeasurement = value2

        // check
        val value3 = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        calibrator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(value3)
        assertEquals(value2, value3)
    }

    @Test
    fun requiredMeasurements_whenValid_setsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )

        // set new value
        calibrator.requiredMeasurements = REQUIRED_MEASUREMENTS

        // check
        assertEquals(REQUIRED_MEASUREMENTS, calibrator.requiredMeasurements)
    }

    @Test
    fun requiredMeasurements_whenInvalid_throwsIllegalArgumentException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalArgumentException::class.java) {
            calibrator.requiredMeasurements = 0
        }
    }

    @Test
    fun requiredMeasurements_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.requiredMeasurements = REQUIRED_MEASUREMENTS
        }
    }

    @Test
    fun onInitializationStarted_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorInitializationStartedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnInitializationStartedListener? =
            calibrator.getPrivateProperty("generatorInitializationStartedListener")
        requireNotNull(generatorInitializationStartedListener)

        generatorInitializationStartedListener.onInitializationStarted(generator)
    }

    @Test
    fun onInitializationStarted_whenListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                initializationStartedListener = initializationStartedListener
            )

        val generatorInitializationStartedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnInitializationStartedListener? =
            calibrator.getPrivateProperty("generatorInitializationStartedListener")
        requireNotNull(generatorInitializationStartedListener)

        generatorInitializationStartedListener.onInitializationStarted(generator)

        verify(exactly = 1) { initializationStartedListener.onInitializationStarted(calibrator) }
    }

    @Test
    fun onInitializationCompleted_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorInitializationCompletedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnInitializationCompletedListener? =
            calibrator.getPrivateProperty("generatorInitializationCompletedListener")
        requireNotNull(generatorInitializationCompletedListener)

        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        generatorInitializationCompletedListener.onInitializationCompleted(
            generator,
            baseNoiseLevel
        )
    }

    @Test
    fun onInitializationCompleted_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                initializationCompletedListener = initializationCompletedListener
            )

        val generatorInitializationCompletedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnInitializationCompletedListener? =
            calibrator.getPrivateProperty("generatorInitializationCompletedListener")
        requireNotNull(generatorInitializationCompletedListener)

        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        generatorInitializationCompletedListener.onInitializationCompleted(
            generator,
            baseNoiseLevel
        )

        verify(exactly = 1) { initializationCompletedListener.onInitializationCompleted(calibrator) }
    }

    @Test
    fun onError_whenNoListeners_stopsGenerator() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        val generatorErrorListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnErrorListener? =
            calibrator.getPrivateProperty("generatorErrorListener")
        requireNotNull(generatorErrorListener)

        generatorErrorListener.onError(generatorSpy, ErrorReason.UNRELIABLE_SENSOR)

        // check
        assertFalse(calibrator.running)
        verify(exactly = 1) { generatorSpy.stop() }
    }

    @Test
    fun onError_whenListenersAvailable_stopsGeneratorAndNotifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                errorListener = errorListener,
                stoppedListener = stoppedListener
            )

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        val generatorErrorListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnErrorListener? =
            calibrator.getPrivateProperty("generatorErrorListener")
        requireNotNull(generatorErrorListener)

        generatorErrorListener.onError(generatorSpy, ErrorReason.UNRELIABLE_SENSOR)

        // check
        assertFalse(calibrator.running)
        verify(exactly = 1) { generatorSpy.stop() }
        verify(exactly = 1) {
            errorListener.onError(
                calibrator,
                CalibratorErrorReason.UNRELIABLE_SENSOR
            )
        }
        verify(exactly = 1) { stoppedListener.onStopped(calibrator) }
    }

    @Test
    fun onStaticIntervalDetected_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorStaticIntervalDetectedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnStaticIntervalDetectedListener? =
            calibrator.getPrivateProperty("generatorStaticIntervalDetectedListener")
        requireNotNull(generatorStaticIntervalDetectedListener)

        generatorStaticIntervalDetectedListener.onStaticIntervalDetected(generator)
    }

    @Test
    fun onStaticIntervalDetected_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                staticIntervalDetectedListener = staticIntervalDetectedListener
            )

        val generatorStaticIntervalDetectedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnStaticIntervalDetectedListener? =
            calibrator.getPrivateProperty("generatorStaticIntervalDetectedListener")
        requireNotNull(generatorStaticIntervalDetectedListener)

        generatorStaticIntervalDetectedListener.onStaticIntervalDetected(generator)

        verify(exactly = 1) { staticIntervalDetectedListener.onStaticIntervalDetected(calibrator) }
    }

    @Test
    fun onDynamicIntervalDetected_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorDynamicIntervalDetectedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnDynamicIntervalDetectedListener? =
            calibrator.getPrivateProperty("generatorDynamicIntervalDetectedListener")
        requireNotNull(generatorDynamicIntervalDetectedListener)

        generatorDynamicIntervalDetectedListener.onDynamicIntervalDetected(generator)
    }

    @Test
    fun onDynamicIntervalDetected_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                dynamicIntervalDetectedListener = dynamicIntervalDetectedListener
            )

        val generatorDynamicIntervalDetectedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnDynamicIntervalDetectedListener? =
            calibrator.getPrivateProperty("generatorDynamicIntervalDetectedListener")
        requireNotNull(generatorDynamicIntervalDetectedListener)

        generatorDynamicIntervalDetectedListener.onDynamicIntervalDetected(generator)

        verify(exactly = 1) { dynamicIntervalDetectedListener.onDynamicIntervalDetected(calibrator) }
    }

    @Test
    fun onStaticIntervalSkipped_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorStaticIntervalSkippedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnStaticIntervalSkippedListener? =
            calibrator.getPrivateProperty("generatorStaticIntervalSkippedListener")
        requireNotNull(generatorStaticIntervalSkippedListener)

        generatorStaticIntervalSkippedListener.onStaticIntervalSkipped(generator)
    }

    @Test
    fun onStaticIntervalSkipped_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                staticIntervalSkippedListener = staticIntervalSkippedListener
            )

        val generatorStaticIntervalSkippedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnStaticIntervalSkippedListener? =
            calibrator.getPrivateProperty("generatorStaticIntervalSkippedListener")
        requireNotNull(generatorStaticIntervalSkippedListener)

        generatorStaticIntervalSkippedListener.onStaticIntervalSkipped(generator)

        verify(exactly = 1) { staticIntervalSkippedListener.onStaticIntervalSkipped(calibrator) }
    }

    @Test
    fun onDynamicIntervalSkipped_whenNoListenerAvailable_makesNoAction() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generatorDynamicIntervalSkippedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnDynamicIntervalSkippedListener? =
            calibrator.getPrivateProperty("generatorDynamicIntervalSkippedListener")
        requireNotNull(generatorDynamicIntervalSkippedListener)

        generatorDynamicIntervalSkippedListener.onDynamicIntervalSkipped(generator)
    }

    @Test
    fun onDynamicIntervalSkipped_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                dynamicIntervalSkippedListener = dynamicIntervalSkippedListener
            )

        val generatorDynamicIntervalSkippedListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnDynamicIntervalSkippedListener? =
            calibrator.getPrivateProperty("generatorDynamicIntervalSkippedListener")
        requireNotNull(generatorDynamicIntervalSkippedListener)

        generatorDynamicIntervalSkippedListener.onDynamicIntervalSkipped(generator)

        verify(exactly = 1) { dynamicIntervalSkippedListener.onDynamicIntervalSkipped(calibrator) }
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_addsMeasurement() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val measurement = StandardDeviationBodyKinematics()
        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.accelerometerMeasurements.size)
        assertSame(measurement, calibrator.accelerometerMeasurements[0])
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                generatedAccelerometerMeasurementListener = generatedAccelerometerMeasurementListener
            )

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val measurement = StandardDeviationBodyKinematics()
        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.accelerometerMeasurements.size)
        assertSame(measurement, calibrator.accelerometerMeasurements[0])

        verify(exactly = 1) {
            generatedAccelerometerMeasurementListener.onGeneratedAccelerometerMeasurement(
                calibrator,
                measurement,
                1,
                StaticIntervalAccelerometerCalibrator.ACCELEROMETER_UNKNOWN_BIAS_MINIMUM_MEASUREMENTS_GENERAL,
            )
        }
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_whenReadyToCalibrate_stopsAndBuildsCalibrator() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = false
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val randomizer = UniformRandomizer()
        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generatorSpy,
            accelerometerMeasurement
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_whenReadyToSolveCalibrationListenerAvailable_notifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener,
            solveCalibrationWhenEnoughMeasurements = false
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val randomizer = UniformRandomizer()
        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generatorSpy,
            accelerometerMeasurement
        )

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_whenSolveCalibrationEnabled_solvesCalibration() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val initialMagneticFluxDensityNorm = truthMagnetic.norm
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generatorSpy,
            calibrator.accelerometerMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
    }

    @Test
    fun onGeneratedAccelerometerMeasurement_whenSolveCalibrationEnabledAndListenersAvailable_solvesCalibrationAndNotifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener,
            stoppedListener = stoppedListener,
            calibrationSolvingStartedListener = calibrationSolvingStartedListener,
            calibrationCompletedListener = calibrationCompletedListener,
            errorListener = errorListener
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedAccelerometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedAccelerometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val initialMagneticFluxDensityNorm = truthMagnetic.norm
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedAccelerometerMeasurement(
            generatorSpy,
            calibrator.accelerometerMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { stoppedListener.onStopped(calibrator) }
        verify(exactly = 1) {
            calibrationSolvingStartedListener.onCalibrationSolvingStarted(
                calibrator
            )
        }
        verify(exactly = 1) { calibrationCompletedListener.onCalibrationCompleted(calibrator) }
        verify { errorListener wasNot Called }
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_addsMeasurement() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.gyroscopeMeasurements.isEmpty())

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.gyroscopeMeasurements.size)
        assertSame(measurement, calibrator.gyroscopeMeasurements[0])
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                generatedGyroscopeMeasurementListener = generatedGyroscopeMeasurementListener
            )

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.gyroscopeMeasurements.size)
        assertSame(measurement, calibrator.gyroscopeMeasurements[0])

        verify(exactly = 1) {
            generatedGyroscopeMeasurementListener.onGeneratedGyroscopeMeasurement(
                calibrator,
                measurement,
                1,
                StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            )
        }
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_whenReadyToCalibrate_stopsAndBuildsCalibrator() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = false
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val randomizer = UniformRandomizer()
        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generatorSpy,
            gyroscopeMeasurement
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_whenReadyToSolveCalibrationListenerAvailable_notifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = false,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val randomizer = UniformRandomizer()
        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generatorSpy,
            gyroscopeMeasurement
        )

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_whenSolveCalibrationEnabled_solvesCalibration() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val initialMagneticFluxDensityNorm = truthMagnetic.norm
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generatorSpy,
            calibrator.gyroscopeMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
    }

    @Test
    fun onGeneratedGyroscopeMeasurement_whenSolveCalibrationEnabledAndListenersAvailable_solvesCalibrationAndNotifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener,
            stoppedListener = stoppedListener,
            calibrationSolvingStartedListener = calibrationSolvingStartedListener,
            calibrationCompletedListener = calibrationCompletedListener,
            errorListener = errorListener
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedGyroscopeMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedGyroscopeMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val initialMagneticFluxDensityNorm = truthMagnetic.norm
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        generatorGeneratedMeasurementListener.onGeneratedGyroscopeMeasurement(
            generatorSpy,
            calibrator.gyroscopeMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { stoppedListener.onStopped(calibrator) }
        verify(exactly = 1) {
            calibrationSolvingStartedListener.onCalibrationSolvingStarted(
                calibrator
            )
        }
        verify(exactly = 1) { calibrationCompletedListener.onCalibrationCompleted(calibrator) }
        verify { errorListener wasNot Called }
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_addsMeasurement() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())
        assertNull(calibrator.initialMagneticFluxDensityNorm)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val nedPosition = location.toNEDPosition()
        val timestamp = Date()
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val norm = truthMagnetic.norm
        every { generator.initialMagneticFluxDensityNorm }.returns(norm)
        val measurement = StandardDeviationBodyMagneticFluxDensity(truthMagnetic)
        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.magnetometerMeasurements.size)
        assertSame(measurement, calibrator.magnetometerMeasurements[0])
        assertEquals(norm, calibrator.initialMagneticFluxDensityNorm)
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenInitialMagneticFluxDensityNorm_keepsInitialMagneticFluxDensityNorm() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())
        assertNull(calibrator.initialMagneticFluxDensityNorm)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val nedPosition = location.toNEDPosition()
        val timestamp = Date()
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val norm = truthMagnetic.norm
        every { generator.initialMagneticFluxDensityNorm }.returns(norm)
        val measurement1 = StandardDeviationBodyMagneticFluxDensity(truthMagnetic)
        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generator,
            measurement1
        )

        assertEquals(1, calibrator.magnetometerMeasurements.size)
        assertSame(measurement1, calibrator.magnetometerMeasurements[0])
        assertEquals(truthMagnetic.norm, calibrator.initialMagneticFluxDensityNorm)

        // call again with a different value
        val measurement2 = StandardDeviationBodyMagneticFluxDensity(BodyMagneticFluxDensity())
        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generator,
            measurement2
        )

        // check that norm is preserved
        assertEquals(truthMagnetic.norm, calibrator.initialMagneticFluxDensityNorm)
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                generatedMagnetometerMeasurementListener = generatedMagnetometerMeasurementListener
            )

        assertTrue(calibrator.accelerometerMeasurements.isEmpty())

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val location = getLocation()
        val nedPosition = location.toNEDPosition()
        val timestamp = Date()
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val measurement = StandardDeviationBodyMagneticFluxDensity(truthMagnetic)
        val norm = truthMagnetic.norm
        every { generator.initialMagneticFluxDensityNorm }.returns(norm)
        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generator,
            measurement
        )

        assertEquals(1, calibrator.magnetometerMeasurements.size)
        assertSame(measurement, calibrator.magnetometerMeasurements[0])

        verify(exactly = 1) {
            generatedMagnetometerMeasurementListener.onGeneratedMagnetometerMeasurement(
                calibrator,
                measurement,
                1,
                StaticIntervalMagnetometerCalibrator.MAGNETOMETER_UNKNOWN_HARD_IRON_MINIMUM_MEASUREMENTS_GENERAL,
            )
        }
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenReadyToCalibrate_stopsAndBuildsCalibrator() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = false
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val location = getLocation()
        val nedPosition = location.toNEDPosition()
        val timestamp = Date()
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity(truthMagnetic)
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val norm = truthMagnetic.norm
        every { generatorSpy.initialMagneticFluxDensityNorm }.returns(norm)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generatorSpy,
            magnetometerMeasurement
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenReadyToSolveCalibrationListenerAvailable_notifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener,
            solveCalibrationWhenEnoughMeasurements = false,
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val accelerometerMeasurement = StandardDeviationBodyKinematics()
        val gyroscopeMeasurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        val location = getLocation()
        val nedPosition = location.toNEDPosition()
        val timestamp = Date()
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity(truthMagnetic)
        (1..calibrator.requiredMeasurements).forEach { _ ->
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
            calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
        }
        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val norm = truthMagnetic.norm
        every { generatorSpy.initialMagneticFluxDensityNorm }.returns(norm)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)
        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generatorSpy,
            magnetometerMeasurement
        )

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)
        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        // gyroscope internal calibrator is only built once accelerometer calibration is solved
        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenSolveCalibrationEnabled_solvesCalibration() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val norm = truthMagnetic.norm
        every { generatorSpy.initialMagneticFluxDensityNorm }.returns(norm)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generatorSpy,
            calibrator.magnetometerMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
    }

    @Test
    fun onGeneratedMagnetometerMeasurement_whenSolveCalibrationEnabledAndListenersAvailable_solvesCalibrationAndNotifies() {
        every { context.getSystemService(Context.SENSOR_SERVICE) }
            .returns(sensorManager)
        every {
            sensorManager.getDefaultSensor(
                AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
            )
        }.returns(
            accelerometerSensor
        )
        every {
            sensorManager.getDefaultSensor(
                GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
            )
        }.returns(
            gyroscopeSensor
        )
        every {
            sensorManager.getDefaultSensor(
                MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
            )
        }.returns(magnetometerSensor)
        every {
            sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
        }.returns(
            gravitySensor
        )

        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()

        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            solveCalibrationWhenEnoughMeasurements = true,
            readyToSolveCalibrationListener = readyToSolveCalibrationListener,
            stoppedListener = stoppedListener,
            calibrationSolvingStartedListener = calibrationSolvingStartedListener,
            calibrationCompletedListener = calibrationCompletedListener,
            errorListener = errorListener
        )

        assertEquals(
            StaticIntervalGyroscopeCalibrator.GYROSCOPE_UNKNOWN_BIAS_MINIMUM_SEQUENCES_GENERAL,
            calibrator.requiredMeasurements
        )
        assertFalse(calibrator.isReadyToSolveCalibration)

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (0 until reqMeasurements).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val earthB = wmmEstimator.estimate(nedPosition, timestamp)
        val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, 0.0, 0.0, 0.0)
        val norm = truthMagnetic.norm
        every { generatorSpy.initialMagneticFluxDensityNorm }.returns(norm)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        var accelerometerInternalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNull(accelerometerInternalCalibrator)

        var gyroscopeInternalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNull(gyroscopeInternalCalibrator)

        var magnetometerInternalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNull(magnetometerInternalCalibrator)

        val generatorGeneratedMeasurementListener: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator.OnGeneratedMagnetometerMeasurementListener? =
            calibrator.getPrivateProperty("generatorGeneratedMagnetometerMeasurementListener")
        requireNotNull(generatorGeneratedMeasurementListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        generatorGeneratedMeasurementListener.onGeneratedMagnetometerMeasurement(
            generatorSpy,
            calibrator.magnetometerMeasurements.last()
        )

        verify(exactly = 1) { generatorSpy.stop() }

        accelerometerInternalCalibrator =
            calibrator.getPrivateProperty("accelerometerInternalCalibrator")
        assertNotNull(accelerometerInternalCalibrator)

        gyroscopeInternalCalibrator =
            calibrator.getPrivateProperty("gyroscopeInternalCalibrator")
        assertNotNull(gyroscopeInternalCalibrator)

        magnetometerInternalCalibrator =
            calibrator.getPrivateProperty("magnetometerInternalCalibrator")
        assertNotNull(magnetometerInternalCalibrator)

        assertNotNull(calibrator.estimatedAccelerometerMa)
        assertNotNull(calibrator.estimatedAccelerometerSx)
        assertNotNull(calibrator.estimatedAccelerometerSy)
        assertNotNull(calibrator.estimatedAccelerometerSz)
        assertNotNull(calibrator.estimatedAccelerometerMxy)
        assertNotNull(calibrator.estimatedAccelerometerMxz)
        assertNotNull(calibrator.estimatedAccelerometerMyx)
        assertNotNull(calibrator.estimatedAccelerometerMyz)
        assertNotNull(calibrator.estimatedAccelerometerMzx)
        assertNotNull(calibrator.estimatedAccelerometerMzy)
        assertNotNull(calibrator.estimatedAccelerometerCovariance)
        assertNotNull(calibrator.estimatedAccelerometerChiSq)
        assertNotNull(calibrator.estimatedAccelerometerMse)
        assertNotNull(calibrator.estimatedAccelerometerBiasX)
        assertNotNull(calibrator.estimatedAccelerometerBiasY)
        assertNotNull(calibrator.estimatedAccelerometerBiasZ)
        assertNotNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
        assertNotNull(calibrator.estimatedAccelerometerBiasAsTriad)
        val accelerometerTriad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(accelerometerTriad))
        assertNotNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedGyroscopeMg)
        assertNotNull(calibrator.estimatedGyroscopeSx)
        assertNotNull(calibrator.estimatedGyroscopeSy)
        assertNotNull(calibrator.estimatedGyroscopeSz)
        assertNotNull(calibrator.estimatedGyroscopeMxy)
        assertNotNull(calibrator.estimatedGyroscopeMxz)
        assertNotNull(calibrator.estimatedGyroscopeMyx)
        assertNotNull(calibrator.estimatedGyroscopeMyz)
        assertNotNull(calibrator.estimatedGyroscopeMzx)
        assertNotNull(calibrator.estimatedGyroscopeMzy)
        assertNotNull(calibrator.estimatedGyroscopeGg)
        assertNotNull(calibrator.estimatedGyroscopeCovariance)
        assertNotNull(calibrator.estimatedGyroscopeChiSq)
        assertNotNull(calibrator.estimatedGyroscopeMse)
        assertNotNull(calibrator.estimatedGyroscopeBiasX)
        assertNotNull(calibrator.estimatedGyroscopeBiasY)
        assertNotNull(calibrator.estimatedGyroscopeBiasZ)
        assertNotNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(bias))
        assertNotNull(calibrator.estimatedGyroscopeBiasAsTriad)
        val angularSpeedTriad = AngularSpeedTriad()
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(angularSpeedTriad))
        assertNotNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)

        assertNotNull(calibrator.estimatedMagnetometerMm)
        assertNotNull(calibrator.estimatedMagnetometerSx)
        assertNotNull(calibrator.estimatedMagnetometerSy)
        assertNotNull(calibrator.estimatedMagnetometerSz)
        assertNotNull(calibrator.estimatedMagnetometerMxy)
        assertNotNull(calibrator.estimatedMagnetometerMxz)
        assertNotNull(calibrator.estimatedMagnetometerMyx)
        assertNotNull(calibrator.estimatedMagnetometerMyz)
        assertNotNull(calibrator.estimatedMagnetometerMzx)
        assertNotNull(calibrator.estimatedMagnetometerMzy)
        assertNotNull(calibrator.estimatedMagnetometerCovariance)
        assertNotNull(calibrator.estimatedMagnetometerChiSq)
        assertNotNull(calibrator.estimatedMagnetometerMse)
        assertNotNull(calibrator.estimatedMagnetometerHardIronX)
        assertNotNull(calibrator.estimatedMagnetometerHardIronY)
        assertNotNull(calibrator.estimatedMagnetometerHardIronZ)
        assertNotNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
        assertNotNull(calibrator.estimatedMagnetometerHardIronAsTriad)
        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))

        verify(exactly = 1) { readyToSolveCalibrationListener.onReadyToSolveCalibration(calibrator) }
        verify(exactly = 1) { stoppedListener.onStopped(calibrator) }
        verify(exactly = 1) {
            calibrationSolvingStartedListener.onCalibrationSolvingStarted(
                calibrator
            )
        }
        verify(exactly = 1) { calibrationCompletedListener.onCalibrationCompleted(calibrator) }
        verify { errorListener wasNot Called }
    }

    @Test
    fun onEstimationCompleted_setsGravityNorm() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gravityNorm)

        val gravityNormCompletedListener: AccumulatedMeasurementEstimator.OnEstimationCompletedListener<GravityNormEstimator>? =
            calibrator.getPrivateProperty("gravityNormCompletedListener")
        requireNotNull(gravityNormCompletedListener)

        val gravityNorm = GravityHelper.getGravityNormForLocation(getLocation())
        every { gravityNormEstimator.averageNorm }.returns(gravityNorm)
        gravityNormCompletedListener.onEstimationCompleted(gravityNormEstimator)

        // check
        assertEquals(gravityNorm, calibrator.gravityNorm)
    }

    @Test
    fun onUnreliable_whenNoListenerAvailable_setsResultAsUnreliable() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertFalse(calibrator.accelerometerResultUnreliable)

        val gravityNormUnreliableListener: AccumulatedMeasurementEstimator.OnUnreliableListener<GravityNormEstimator>? =
            calibrator.getPrivateProperty("gravityNormUnreliableListener")
        requireNotNull(gravityNormUnreliableListener)

        gravityNormUnreliableListener.onUnreliable(gravityNormEstimator)

        assertTrue(calibrator.accelerometerResultUnreliable)
    }

    @Test
    fun onUnreliable_whenListenerAvailable_setsResultAsUnreliable() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                unreliableGravityNormEstimationListener = unreliableGravityNormEstimationListener
            )

        // check default value
        assertFalse(calibrator.accelerometerResultUnreliable)

        val gravityNormUnreliableListener: AccumulatedMeasurementEstimator.OnUnreliableListener<GravityNormEstimator>? =
            calibrator.getPrivateProperty("gravityNormUnreliableListener")
        requireNotNull(gravityNormUnreliableListener)

        gravityNormUnreliableListener.onUnreliable(gravityNormEstimator)

        assertTrue(calibrator.accelerometerResultUnreliable)
        verify(exactly = 1) {
            unreliableGravityNormEstimationListener.onUnreliableGravityEstimation(
                calibrator
            )
        }
    }

    @Test
    fun magnetometerBaseNoiseLevel_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        verify(exactly = 1) { generatorSpy.magnetometerBaseNoiseLevel }
    }

    @Test
    fun magnetometerBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        val baseNoiseLevel1 = MagneticFluxDensity(baseNoiseLevel, MagneticFluxDensityUnit.TESLA)
        every { generatorSpy.magnetometerBaseNoiseLevelAsMeasurement }.returns(baseNoiseLevel1)
        calibrator.setPrivateProperty("generator", generatorSpy)

        val baseNoiseLevel2 = calibrator.magnetometerBaseNoiseLevelAsMeasurement
        assertSame(baseNoiseLevel1, baseNoiseLevel2)

        verify(exactly = 1) { generatorSpy.magnetometerBaseNoiseLevelAsMeasurement }
    }

    @Test
    fun getMagnetometerBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerBaseNoiseLevelAsMeasurement(b))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.getMagnetometerBaseNoiseLevelAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = baseNoiseLevel
            result.unit = MagneticFluxDensityUnit.TESLA
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getMagnetometerBaseNoiseLevelAsMeasurement(b))

        // check
        assertEquals(baseNoiseLevel, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
        verify(exactly = 1) { generatorSpy.getMagnetometerBaseNoiseLevelAsMeasurement(b) }
    }

    @Test
    fun gyroscopeBaseNoiseLevel_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        verify(exactly = 1) { generatorSpy.gyroscopeBaseNoiseLevel }
    }

    @Test
    fun gyroscopeBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val value = randomizer.nextDouble()
        val baseNoiseLevel1 = AngularSpeed(value, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { generatorSpy.gyroscopeBaseNoiseLevelAsMeasurement }.returns(baseNoiseLevel1)
        calibrator.setPrivateProperty("generator", generatorSpy)

        val baseNoiseLevel2 = calibrator.gyroscopeBaseNoiseLevelAsMeasurement
        assertSame(baseNoiseLevel1, baseNoiseLevel2)

        verify(exactly = 1) { generatorSpy.gyroscopeBaseNoiseLevelAsMeasurement }
    }

    @Test
    fun getGyroscopeBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val w = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeBaseNoiseLevelAsMeasurement(w))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val value = randomizer.nextDouble()
        every { generatorSpy.getGyroscopeBaseNoiseLevelAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = value
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getGyroscopeBaseNoiseLevelAsMeasurement(w))

        // check
        assertEquals(value, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
        verify(exactly = 1) { generatorSpy.getGyroscopeBaseNoiseLevelAsMeasurement(w) }
    }

    @Test
    fun accelerometerBaseNoiseLevel_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        verify(exactly = 1) { generatorSpy.accelerometerBaseNoiseLevel }
    }

    @Test
    fun accelerometerBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        val baseNoiseLevel1 =
            Acceleration(baseNoiseLevel, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { generatorSpy.accelerometerBaseNoiseLevelAsMeasurement }.returns(baseNoiseLevel1)
        calibrator.setPrivateProperty("generator", generatorSpy)

        val baseNoiseLevel2 = calibrator.accelerometerBaseNoiseLevelAsMeasurement
        assertSame(baseNoiseLevel1, baseNoiseLevel2)
        verify(exactly = 1) { generatorSpy.accelerometerBaseNoiseLevelAsMeasurement }
    }

    @Test
    fun getAccelerometerBaseNoiseLevelAsMeasurement_getsGeneratorBaseNoiseLevel() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerBaseNoiseLevelAsMeasurement(acceleration))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.getAccelerometerBaseNoiseLevelAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = baseNoiseLevel
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getAccelerometerBaseNoiseLevelAsMeasurement(acceleration))

        // check
        assertEquals(baseNoiseLevel, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
        verify(exactly = 1) { generatorSpy.getAccelerometerBaseNoiseLevelAsMeasurement(acceleration) }
    }

    @Test
    fun accelerometerBaseNoiseLevelPsd_getsGeneratorBaseNoiseLevelPsd() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevelPsd = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevelPsd }.returns(baseNoiseLevelPsd)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(baseNoiseLevelPsd, calibrator.accelerometerBaseNoiseLevelPsd)
        verify(exactly = 1) { generatorSpy.accelerometerBaseNoiseLevelPsd }
    }

    @Test
    fun accelerometerBaseNoiseLevelRootPsd_getsGeneratorBaseNoiseLevelRootPsd() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val baseNoiseLevelRootPsd = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevelRootPsd }.returns(baseNoiseLevelRootPsd)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(baseNoiseLevelRootPsd, calibrator.accelerometerBaseNoiseLevelRootPsd)
        verify(exactly = 1) { generatorSpy.accelerometerBaseNoiseLevelRootPsd }
    }

    @Test
    fun threshold_getsGeneratorThreshold() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.threshold)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val threshold = randomizer.nextDouble()
        every { generatorSpy.threshold }.returns(threshold)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(threshold, calibrator.threshold)
        verify(exactly = 1) { generatorSpy.threshold }
    }

    @Test
    fun thresholdAsMeasurement_getsGeneratorThresholdAsMeasurement() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.thresholdAsMeasurement)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val threshold = randomizer.nextDouble()
        val acceleration = Acceleration(threshold, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { generatorSpy.thresholdAsMeasurement }.returns(acceleration)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertSame(acceleration, calibrator.thresholdAsMeasurement)
        verify(exactly = 1) { generatorSpy.thresholdAsMeasurement }
    }

    @Test
    fun getThresholdAsMeasurement_getsGeneratorThresholdAsMeasurement() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getThresholdAsMeasurement(acceleration))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val threshold = randomizer.nextDouble()
        every { generatorSpy.getThresholdAsMeasurement(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = threshold
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getThresholdAsMeasurement(acceleration))
        assertEquals(threshold, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
        verify(exactly = 1) { generatorSpy.getThresholdAsMeasurement(acceleration) }
    }

    @Test
    fun processedStaticSamples_getsGeneratorProcessedStaticSamples() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val processedStaticSamples = randomizer.nextInt()
        every { generatorSpy.processedStaticSamples }.returns(processedStaticSamples)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(processedStaticSamples, calibrator.processedStaticSamples)
        verify(exactly = 1) { generatorSpy.processedStaticSamples }
    }

    @Test
    fun processedDynamicSamples_getsGeneratorProcessedDynamicSamples() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val processedDynamicSamples = randomizer.nextInt()
        every { generatorSpy.processedDynamicSamples }.returns(processedDynamicSamples)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(processedDynamicSamples, calibrator.processedDynamicSamples)
        verify(exactly = 1) { generatorSpy.processedDynamicSamples }
    }

    @Test
    fun isStaticIntervalSkipped_getsGeneratorStaticIntervalSkipped() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        every { generatorSpy.isStaticIntervalSkipped }.returns(true)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.isStaticIntervalSkipped)
        verify(exactly = 1) { generatorSpy.isStaticIntervalSkipped }
    }

    @Test
    fun isDynamicIntervalSkipped_getsGeneratorStaticIntervalSkipped() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        every { generatorSpy.isDynamicIntervalSkipped }.returns(true)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.isDynamicIntervalSkipped)
        verify(exactly = 1) { generatorSpy.isDynamicIntervalSkipped }
    }

    @Test
    fun accelerometerAverageTimeInterval_getsGeneratorAccelerometerAverageTimeInterval() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val averageTimeInterval = randomizer.nextDouble()
        every { generatorSpy.accelerometerAverageTimeInterval }.returns(averageTimeInterval)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(averageTimeInterval, calibrator.accelerometerAverageTimeInterval)
        verify(exactly = 1) { generatorSpy.accelerometerAverageTimeInterval }
    }

    @Test
    fun accelerometerAverageTimeIntervalAsTime_getsGeneratorAccelerometerAverageTimeInterval() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val averageTimeInterval = randomizer.nextDouble()
        val time = Time(averageTimeInterval, TimeUnit.SECOND)
        every { generatorSpy.accelerometerAverageTimeIntervalAsTime }.returns(time)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertSame(time, calibrator.accelerometerAverageTimeIntervalAsTime)
        verify(exactly = 1) { generatorSpy.accelerometerAverageTimeIntervalAsTime }
    }

    @Test
    fun getAccelerometerAverageTimeIntervalAsTime_getsGeneratorAccelerometerAverageTimeInterval() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val time = Time(0.0, TimeUnit.SECOND)
        assertFalse(calibrator.getAccelerometerAverageTimeIntervalAsTime(time))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val averageTimeInterval = randomizer.nextDouble()
        every { generatorSpy.getAccelerometerAverageTimeIntervalAsTime(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Time
            result.value = averageTimeInterval
            result.unit = TimeUnit.SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getAccelerometerAverageTimeIntervalAsTime(time))
        assertEquals(averageTimeInterval, time.value.toDouble(), 0.0)
        assertEquals(TimeUnit.SECOND, time.unit)
        verify(exactly = 1) { generatorSpy.getAccelerometerAverageTimeIntervalAsTime(time) }
    }

    @Test
    fun accelerometerTimeIntervalVariance_getsGeneratorAccelerometerTimeIntervalVariance() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerTimeIntervalVariance)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val timeIntervalVariance = randomizer.nextDouble()
        every { generatorSpy.accelerometerTimeIntervalVariance }.returns(timeIntervalVariance)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(timeIntervalVariance, calibrator.accelerometerTimeIntervalVariance)
        verify(exactly = 1) { generatorSpy.accelerometerTimeIntervalVariance }
    }

    @Test
    fun accelerometerTimeIntervalStandardDeviation_getsGeneratorAccelerometerTimeIntervalStandardDeviation() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerTimeIntervalStandardDeviation)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val timeIntervalStandardDeviation = randomizer.nextDouble()
        every { generatorSpy.accelerometerTimeIntervalStandardDeviation }.returns(
            timeIntervalStandardDeviation
        )
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(
            timeIntervalStandardDeviation,
            calibrator.accelerometerTimeIntervalStandardDeviation
        )
        verify(exactly = 1) { generatorSpy.accelerometerTimeIntervalStandardDeviation }
    }

    @Test
    fun accelerometerTimeIntervalStandardDeviationAsTime_getsGeneratorAccelerometerTimeIntervalStandardDeviationAsTime() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val value = randomizer.nextDouble()
        val time = Time(value, TimeUnit.SECOND)
        every { generatorSpy.accelerometerTimeIntervalStandardDeviationAsTime }.returns(time)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertSame(time, calibrator.accelerometerTimeIntervalStandardDeviationAsTime)
        verify(exactly = 1) { generatorSpy.accelerometerTimeIntervalStandardDeviationAsTime }
    }

    @Test
    fun getAccelerometerTimeIntervalStandardDeviationAsTime_getsGeneratorAccelerometerTimeIntervalStandardDeviationAsTime() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val time = Time(0.0, TimeUnit.SECOND)
        assertFalse(calibrator.getAccelerometerTimeIntervalStandardDeviationAsTime(time))

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val value = randomizer.nextDouble()
        every { generatorSpy.getAccelerometerTimeIntervalStandardDeviationAsTime(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Time
            result.value = value
            result.unit = TimeUnit.SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertTrue(calibrator.getAccelerometerTimeIntervalStandardDeviationAsTime(time))
        assertEquals(value, time.value.toDouble(), 0.0)
        assertEquals(TimeUnit.SECOND, time.unit)
        verify(exactly = 1) { generatorSpy.getAccelerometerTimeIntervalStandardDeviationAsTime(time) }
    }

    @Test
    fun numberOfProcessedGyroscopeMeasurements_getsGeneratorNumberOfProcessedMagnetometerMeasurements() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val numberOfProcessedGyroscopeMeasurements = randomizer.nextInt()
        every { generatorSpy.numberOfProcessedGyroscopeMeasurements }.returns(
            numberOfProcessedGyroscopeMeasurements
        )
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(
            numberOfProcessedGyroscopeMeasurements,
            calibrator.numberOfProcessedGyroscopeMeasurements
        )

        verify(exactly = 1) { generatorSpy.numberOfProcessedGyroscopeMeasurements }
    }

    @Test
    fun numberOfProcessedMagnetometerMeasurements_getsGeneratorNumberOfProcessedMagnetometerMeasurements() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()
        val numberOfProcessedMagnetometerMeasurements = randomizer.nextInt()
        every { generatorSpy.numberOfProcessedMagnetometerMeasurements }.returns(
            numberOfProcessedMagnetometerMeasurements
        )
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(
            numberOfProcessedMagnetometerMeasurements,
            calibrator.numberOfProcessedMagnetometerMeasurements
        )

        verify(exactly = 1) { generatorSpy.numberOfProcessedMagnetometerMeasurements }
    }

    @Test
    fun numberOfProcessedAccelerometerMeasurements_getsGeneratorNumberOfProcessedAccelerometerMeasurements() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val randomizer = UniformRandomizer()

        val numberOfProcessedAccelerometerMeasurements = randomizer.nextInt()
        every { generatorSpy.numberOfProcessedAccelerometerMeasurements }.returns(
            numberOfProcessedAccelerometerMeasurements
        )
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(
            numberOfProcessedAccelerometerMeasurements,
            calibrator.numberOfProcessedAccelerometerMeasurements
        )

        verify(exactly = 1) { generatorSpy.numberOfProcessedAccelerometerMeasurements }
    }

    @Test
    fun gyroscopeInitialBiasX_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasX)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)

        assertEquals(initialBiasX, calibrator.gyroscopeInitialBiasX)
    }

    @Test
    fun gyroscopeInitialBiasY_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasY)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)

        assertEquals(initialBiasY, calibrator.gyroscopeInitialBiasY)
    }

    @Test
    fun gyroscopeInitialBiasZ_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasZ)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        assertEquals(initialBiasZ, calibrator.gyroscopeInitialBiasZ)
    }

    @Test
    fun gyroscopeInitialBiasXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasXAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)

        val bias = calibrator.gyroscopeInitialBiasXAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasX, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun getGyroscopeInitialBiasXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeInitialBiasXAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)

        assertTrue(calibrator.getGyroscopeInitialBiasXAsMeasurement(bias))
        assertEquals(initialBiasX, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun gyroscopeInitialBiasYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasYAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)

        val bias = calibrator.gyroscopeInitialBiasYAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasY, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun getGyroscopeInitialBiasYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeInitialBiasYAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)

        assertTrue(calibrator.getGyroscopeInitialBiasYAsMeasurement(bias))
        assertEquals(initialBiasY, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun gyroscopeInitialBiasZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasZAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val bias = calibrator.gyroscopeInitialBiasZAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasZ, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun getGyroscopeInitialBiasZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getGyroscopeInitialBiasZAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        assertTrue(calibrator.getGyroscopeInitialBiasZAsMeasurement(bias))
        assertEquals(initialBiasZ, bias.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, bias.unit)
    }

    @Test
    fun gyroscopeInitialBiasAsTriad_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.gyroscopeInitialBiasAsTriad)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)

        assertNull(calibrator.gyroscopeInitialBiasAsTriad)

        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)

        assertNull(calibrator.gyroscopeInitialBiasAsTriad)

        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val triad = calibrator.gyroscopeInitialBiasAsTriad
        requireNotNull(triad)
        assertEquals(initialBiasX, triad.valueX, 0.0)
        assertEquals(initialBiasY, triad.valueY, 0.0)
        assertEquals(initialBiasZ, triad.valueZ, 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, triad.unit)
    }

    @Test
    fun magnetometerInitialHardIronX_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronX)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)

        assertEquals(initialHardIronX, calibrator.magnetometerInitialHardIronX)
    }

    @Test
    fun magnetometerInitialHardIronY_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronY)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronY = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)

        assertEquals(initialHardIronY, calibrator.magnetometerInitialHardIronY)
    }

    @Test
    fun magnetometerInitialHardIronZ_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronZ)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)

        assertEquals(initialHardIronZ, calibrator.magnetometerInitialHardIronZ)
    }

    @Test
    fun magnetometerInitialHardIronXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronXAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)

        val hardIron = calibrator.magnetometerInitialHardIronXAsMeasurement
        requireNotNull(hardIron)
        assertEquals(initialHardIronX, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun getMagnetometerInitialHardIronXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val hardIron = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerInitialHardIronXAsMeasurement(hardIron))

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)

        assertTrue(calibrator.getMagnetometerInitialHardIronXAsMeasurement(hardIron))
        assertEquals(initialHardIronX, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun magnetometerInitialHardIronYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronYAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronY = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)

        val hardIron = calibrator.magnetometerInitialHardIronYAsMeasurement
        requireNotNull(hardIron)
        assertEquals(initialHardIronY, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun getMagnetometerInitialHardIronYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val hardIron = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerInitialHardIronYAsMeasurement(hardIron))

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronY = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)

        assertTrue(calibrator.getMagnetometerInitialHardIronYAsMeasurement(hardIron))
        assertEquals(initialHardIronY, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun magnetometerInitialHardIronZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronZAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)

        val hardIron = calibrator.magnetometerInitialHardIronZAsMeasurement
        requireNotNull(hardIron)
        assertEquals(initialHardIronZ, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun getMagnetometerInitialHardIronZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val hardIron = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getMagnetometerInitialHardIronZAsMeasurement(hardIron))

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)

        assertTrue(calibrator.getMagnetometerInitialHardIronZAsMeasurement(hardIron))
        assertEquals(initialHardIronZ, hardIron.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, hardIron.unit)
    }

    @Test
    fun magnetometerInitialHardIronAsTriad_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.magnetometerInitialHardIronAsTriad)

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)

        val triad = calibrator.magnetometerInitialHardIronAsTriad
        requireNotNull(triad)
        assertEquals(initialHardIronX, triad.valueX, 0.0)
        assertEquals(initialHardIronY, triad.valueY, 0.0)
        assertEquals(initialHardIronZ, triad.valueZ, 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, triad.unit)
    }

    @Test
    fun getMagnetometerInitialHardIronAsTriad_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val triad = MagneticFluxDensityTriad()
        assertFalse(calibrator.getMagnetometerInitialHardIronAsTriad(triad))

        // set new value
        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)

        assertFalse(calibrator.getMagnetometerInitialHardIronAsTriad(triad))

        val initialHardIronY = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)

        assertFalse(calibrator.getMagnetometerInitialHardIronAsTriad(triad))

        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)

        // check
        assertTrue(calibrator.getMagnetometerInitialHardIronAsTriad(triad))
        assertEquals(initialHardIronX, triad.valueX, 0.0)
        assertEquals(initialHardIronY, triad.valueY, 0.0)
        assertEquals(initialHardIronZ, triad.valueZ, 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, triad.unit)
    }

    @Test
    fun accelerometerInitialBiasX_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasX)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)

        assertEquals(initialBiasX, calibrator.accelerometerInitialBiasX)
    }

    @Test
    fun accelerometerInitialBiasY_getExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasY)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)

        assertEquals(initialBiasY, calibrator.accelerometerInitialBiasY)
    }

    @Test
    fun accelerometerInitialBiasZ_getExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasZ)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)

        assertEquals(initialBiasZ, calibrator.accelerometerInitialBiasZ)
    }

    @Test
    fun accelerometerInitialBiasXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasXAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)

        val bias = calibrator.accelerometerInitialBiasXAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasX, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun getAccelerometerInitialBiasXAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerInitialBiasXAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)

        // check
        assertTrue(calibrator.getAccelerometerInitialBiasXAsMeasurement(bias))
        assertEquals(initialBiasX, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun accelerometerInitialBiasYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasYAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)

        val bias = calibrator.accelerometerInitialBiasYAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasY, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun getAccelerometerInitialBiasYAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerInitialBiasYAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)

        // check
        assertTrue(calibrator.getAccelerometerInitialBiasYAsMeasurement(bias))
        assertEquals(initialBiasY, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun accelerometerInitialBiasZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasZAsMeasurement)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)

        val bias = calibrator.accelerometerInitialBiasZAsMeasurement
        requireNotNull(bias)
        assertEquals(initialBiasZ, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun getAccelerometerInitialBiasZAsMeasurement_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val bias = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getAccelerometerInitialBiasZAsMeasurement(bias))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)

        // check
        assertTrue(calibrator.getAccelerometerInitialBiasZAsMeasurement(bias))
        assertEquals(initialBiasZ, bias.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, bias.unit)
    }

    @Test
    fun accelerometerInitialBiasAsTriad_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        assertNull(calibrator.accelerometerInitialBiasAsTriad)

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)

        assertNull(calibrator.accelerometerInitialBiasAsTriad)

        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)

        assertNull(calibrator.accelerometerInitialBiasAsTriad)

        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)

        // check
        val triad = calibrator.accelerometerInitialBiasAsTriad
        requireNotNull(triad)
        assertEquals(initialBiasX, triad.valueX, 0.0)
        assertEquals(initialBiasY, triad.valueY, 0.0)
        assertEquals(initialBiasZ, triad.valueZ, 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, triad.unit)
    }

    @Test
    fun getAccelerometerInitialBiasAsTriad_getsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        // check default value
        val triad = AccelerationTriad()
        assertFalse(calibrator.getAccelerometerInitialBiasAsTriad(triad))

        // set new value
        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)

        assertFalse(calibrator.getAccelerometerInitialBiasAsTriad(triad))

        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)

        assertFalse(calibrator.getAccelerometerInitialBiasAsTriad(triad))

        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)

        // check
        assertTrue(calibrator.getAccelerometerInitialBiasAsTriad(triad))
        assertEquals(initialBiasX, triad.valueX, 0.0)
        assertEquals(initialBiasY, triad.valueY, 0.0)
        assertEquals(initialBiasZ, triad.valueZ, 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, triad.unit)
    }

    @Test
    fun start_whenNotRunningAndGravityNormNotEstimated_resetsAndStartsGenerator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location
        )

        assertFalse(calibrator.running)
        assertFalse(calibrator.isGravityNormEstimated)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        calibrator.setPrivateProperty("accelerometerResultUnreliable", true)
        calibrator.setPrivateProperty("accelerometerInitialBiasX", 0.0)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", 0.0)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", 0.0)

        calibrator.setPrivateProperty("gyroscopeInitialBiasX", 0.0)
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", 0.0)
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", 0.0)

        calibrator.setPrivateProperty("magnetometerInitialHardIronX", 0.0)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", 0.0)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", 0.0)

        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        calibrator.setPrivateProperty(
            "gyroscopeInternalCalibrator",
            gyroscopeNonLinearInternalCalibrator
        )

        calibrator.setPrivateProperty(
            "magnetometerInternalCalibrator",
            magnetometerNonLinearInternalCalibrator
        )

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.start() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        calibrator.start()

        // check
        assertNull(calibrator.gravityNorm)
        assertFalse(calibrator.accelerometerResultUnreliable)
        assertNull(calibrator.accelerometerInitialBiasX)
        assertNull(calibrator.accelerometerInitialBiasY)
        assertNull(calibrator.accelerometerInitialBiasZ)
        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.magnetometerInitialHardIronX)
        assertNull(calibrator.magnetometerInitialHardIronY)
        assertNull(calibrator.magnetometerInitialHardIronZ)
        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))

        assertTrue(calibrator.running)

        verify { gravityNormEstimatorSpy wasNot Called }
        verify(exactly = 1) { generatorSpy.start() }
    }

    @Test
    fun start_whenNotRunningAndGravityNormEstimated_resetsAndStartsGenerator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertFalse(calibrator.running)
        assertTrue(calibrator.isGravityNormEstimated)

        val gravityNorm = GravityHelper.getGravityNormForLocation(getLocation())
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        calibrator.setPrivateProperty("accelerometerResultUnreliable", true)
        calibrator.setPrivateProperty("accelerometerInitialBiasX", 0.0)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", 0.0)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", 0.0)

        calibrator.setPrivateProperty("gyroscopeInitialBiasX", 0.0)
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", 0.0)
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", 0.0)

        calibrator.setPrivateProperty("magnetometerInitialHardIronX", 0.0)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", 0.0)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", 0.0)

        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        calibrator.setPrivateProperty(
            "gyroscopeInternalCalibrator",
            gyroscopeNonLinearInternalCalibrator
        )

        calibrator.setPrivateProperty(
            "magnetometerInternalCalibrator",
            magnetometerNonLinearInternalCalibrator
        )

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        justRun { gravityNormEstimatorSpy.start() }
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.start() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        calibrator.start()

        // check
        assertNull(calibrator.gravityNorm)
        assertFalse(calibrator.accelerometerResultUnreliable)
        assertNull(calibrator.accelerometerInitialBiasX)
        assertNull(calibrator.accelerometerInitialBiasY)
        assertNull(calibrator.accelerometerInitialBiasZ)
        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.magnetometerInitialHardIronX)
        assertNull(calibrator.magnetometerInitialHardIronY)
        assertNull(calibrator.magnetometerInitialHardIronZ)
        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))

        assertTrue(calibrator.running)

        verify(exactly = 1) { gravityNormEstimatorSpy.start() }
        verify(exactly = 1) { generatorSpy.start() }
    }

    @Test
    fun start_whenRunning_throwsIllegalStateException() {
        mockkStatic(SystemClock::class) {
            val startTimestamp = System.nanoTime()
            every { SystemClock.elapsedRealtimeNanos() }.returns(startTimestamp)

            every { context.getSystemService(Context.SENSOR_SERVICE) }
                .returns(sensorManager)
            every {
                sensorManager.getDefaultSensor(
                    AccelerometerSensorType.ACCELEROMETER_UNCALIBRATED.value
                )
            }.returns(
                accelerometerSensor
            )
            every {
                sensorManager.getDefaultSensor(
                    GyroscopeSensorType.GYROSCOPE_UNCALIBRATED.value
                )
            }.returns(
                gyroscopeSensor
            )
            every {
                sensorManager.getDefaultSensor(
                    MagnetometerSensorType.MAGNETOMETER_UNCALIBRATED.value
                )
            }.returns(magnetometerSensor)
            every {
                sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY)
            }.returns(
                gravitySensor
            )
            every {
                sensorManager.registerListener(
                    any<SensorEventListener>(), any<Sensor>(), any()
                )
            }.returns(true)

            val calibrator =
                StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

            assertFalse(calibrator.running)

            calibrator.start()

            assertTrue(calibrator.running)

            assertThrows(IllegalStateException::class.java) {
                calibrator.start()
            }
        }
    }

    @Test
    fun stop_whenGravityNormEstimatorNotRunning_stopsGenerator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        calibrator.stop()

        assertFalse(calibrator.running)
        verify(exactly = 1) { generatorSpy.stop() }
        verify(exactly = 1) { gravityNormEstimatorSpy.running }
        verify(exactly = 0) { gravityNormEstimatorSpy.stop() }
        assertFalse(gravityNormEstimatorSpy.running)
    }

    @Test
    fun stop_whenGravityNormEstimatorRunning_stopsGenerator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        val gravityNormEstimator: GravityNormEstimator? =
            calibrator.getPrivateProperty("gravityNormEstimator")
        requireNotNull(gravityNormEstimator)
        val gravityNormEstimatorSpy = spyk(gravityNormEstimator)
        every { gravityNormEstimatorSpy.running }.returns(true)
        justRun { gravityNormEstimatorSpy.stop() }
        calibrator.setPrivateProperty("gravityNormEstimator", gravityNormEstimatorSpy)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        calibrator.stop()

        assertFalse(calibrator.running)
        verify(exactly = 1) { generatorSpy.stop() }
        verify(exactly = 1) { gravityNormEstimatorSpy.running }
        verify(exactly = 1) { gravityNormEstimatorSpy.stop() }
        assertTrue(gravityNormEstimatorSpy.running)
    }

    @Test
    fun stop_whenListenerAvailable_notifies() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                stoppedListener = stoppedListener
            )

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        justRun { generatorSpy.stop() }
        calibrator.setPrivateProperty("generator", generatorSpy)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )
        assertTrue(calibrator.running)

        calibrator.stop()

        assertFalse(calibrator.running)
        verify(exactly = 1) { generatorSpy.stop() }
        verify(exactly = 1) { stoppedListener.onStopped(calibrator) }
    }

    @Test
    fun calibrate_whenNotReadyToSolveCalibration_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertThrows(IllegalStateException::class.java) {
            calibrator.calibrate()
        }
    }

    @Test
    fun calibrate_whenRunning_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        setPrivateProperty(
            BaseStaticIntervalWithMeasurementGeneratorCalibrator::class,
            calibrator,
            "running",
            true
        )

        assertThrows(IllegalStateException::class.java) {
            calibrator.calibrate()
        }
    }

    @Test
    fun calibrate_whenReadyNotRunningAndInternalCalibratorAndListeners_callsInternalCalibratorAndNotifies() {
        val wmmEstimator = WMMEarthMagneticFluxDensityEstimator()
        val location = getLocation()
        val timestamp = Date()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            calibrationSolvingStartedListener = calibrationSolvingStartedListener,
            calibrationCompletedListener = calibrationCompletedListener
        )

        // add enough measurements
        val requiredMeasurements = calibrator.requiredMeasurements
        assertEquals(13, requiredMeasurements)
        val minimumRequiredMeasurements = calibrator.minimumRequiredMeasurements
        assertEquals(13, minimumRequiredMeasurements)
        val reqMeasurements = requiredMeasurements.coerceAtLeast(minimumRequiredMeasurements)

        val nedPosition = location.toNEDPosition()

        val ba = generateBa()
        val bg = generateBg()
        val ma = generateMa()
        val mg = generateGeneralMg()
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        val accelNoiseRootPSD = 0.0
        val gyroNoiseRootPSD = 0.0
        val accelQuantLevel = 0.0
        val gyroQuantLevel = 0.0
        val errors = IMUErrors(
            ba,
            bg,
            ma,
            mg,
            gg,
            accelNoiseRootPSD,
            gyroNoiseRootPSD,
            accelQuantLevel,
            gyroQuantLevel
        )

        val hardIron = generateHardIron()
        val mm = generateSoftIron()

        val random = Random()
        val randomizer = UniformRandomizer(random)

        val sqrtTimeInterval = sqrt(TIME_INTERVAL_SECONDS)
        val specificForceStandardDeviation = getAccelNoiseRootPSD() / sqrtTimeInterval
        val angularRateStandardDeviation = getGyroNoiseRootPSD() / sqrtTimeInterval

        val sequences =
            mutableListOf<BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>>()
        (1..13).forEach { _ ->
            // initial attitude of sequence
            val roll = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val pitch = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val yaw = Math.toRadians(randomizer.nextDouble(MIN_ANGLE_DEGREES, MAX_ANGLE_DEGREES))
            val nedC = CoordinateTransformation(
                roll,
                pitch,
                yaw,
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )

            val beforeQ = Quaternion()
            nedC.asRotation(beforeQ)

            val nedFrame = NEDFrame(nedPosition, nedC)
            val ecefFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(nedFrame)

            val trueBeforeGravityKinematics =
                ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    ecefFrame,
                    ecefFrame
                )
            val measuredBeforeGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueBeforeGravityKinematics,
                errors,
                random
            )
            val beforeMeanFx = measuredBeforeGravityKinematics.fx
            val beforeMeanFy = measuredBeforeGravityKinematics.fy
            val beforeMeanFz = measuredBeforeGravityKinematics.fz

            val deltaRoll = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaPitch = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )
            val deltaYaw = Math.toRadians(
                randomizer.nextDouble(MIN_ANGLE_VARIATION_DEGREES, MAX_ANGLE_VARIATION_DEGREES)
            )

            val oldNedFrame = NEDFrame(nedFrame)
            val newNedFrame = NEDFrame()
            val oldEcefFrame = ECEFFrame()
            val newEcefFrame = ECEFFrame()
            var oldRoll = roll - deltaRoll
            var oldPitch = pitch - deltaPitch
            var oldYaw = yaw - deltaYaw

            val trueSequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val sequence = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            sequence.setBeforeMeanSpecificForceCoordinates(beforeMeanFx, beforeMeanFy, beforeMeanFz)

            val trueTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()
            val measuredTimedKinematicsList = mutableListOf<StandardDeviationTimedBodyKinematics>()

            val earthB = wmmEstimator.estimate(nedPosition, timestamp)
            val truthMagnetic = BodyMagneticFluxDensityEstimator.estimate(earthB, roll, pitch, yaw)
            val measuredMagnetic =
                BodyMagneticFluxDensityGenerator.generate(truthMagnetic, hardIron, mm)

            val magnetometerMeasurement =
                StandardDeviationBodyMagneticFluxDensity(measuredMagnetic,
                    MAGNETOMETER_NOISE_STD
                )
            calibrator.magnetometerMeasurements.add(magnetometerMeasurement)

            for (j in 0 until reqMeasurements) {
                val newRoll = oldRoll + deltaRoll
                val newPitch = oldPitch + deltaPitch
                val newYaw = oldYaw + deltaYaw
                val newNedC = CoordinateTransformation(
                    newRoll,
                    newPitch,
                    newYaw,
                    FrameType.BODY_FRAME,
                    FrameType.LOCAL_NAVIGATION_FRAME
                )
                val newNedPosition = oldNedFrame.position

                newNedFrame.position = newNedPosition
                newNedFrame.coordinateTransformation = newNedC

                NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)
                NEDtoECEFFrameConverter.convertNEDtoECEF(oldNedFrame, oldEcefFrame)

                val timestampSeconds = j * TIME_INTERVAL_SECONDS

                // compute ground-truth kinematics that should be generated at provided
                // position, velocity and orientation
                val trueKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                    TIME_INTERVAL_SECONDS,
                    newEcefFrame,
                    oldEcefFrame
                )

                // apply known calibration parameters to distort ground-truth and generate a
                // measured kinematics sample
                val measuredKinematics = BodyKinematicsGenerator.generate(
                    TIME_INTERVAL_SECONDS,
                    trueKinematics,
                    errors,
                    random
                )

                val trueTimedKinematics = StandardDeviationTimedBodyKinematics(
                    trueKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                val measuredTimedKinematics = StandardDeviationTimedBodyKinematics(
                    measuredKinematics,
                    timestampSeconds,
                    specificForceStandardDeviation,
                    angularRateStandardDeviation
                )

                trueTimedKinematicsList.add(trueTimedKinematics)
                measuredTimedKinematicsList.add(measuredTimedKinematics)

                oldNedFrame.copyFrom(newNedFrame)
                oldRoll = newRoll
                oldPitch = newPitch
                oldYaw = newYaw
            }
            trueSequence.setItems(trueTimedKinematicsList)
            sequence.setItems(measuredTimedKinematicsList)

            val afterQ = Quaternion()
            QuaternionIntegrator.integrateGyroSequence(
                trueSequence,
                beforeQ,
                QuaternionStepIntegratorType.RUNGE_KUTTA,
                afterQ
            )

            val newNedC = CoordinateTransformation(
                afterQ.asInhomogeneousMatrix(),
                FrameType.BODY_FRAME,
                FrameType.LOCAL_NAVIGATION_FRAME
            )
            newNedFrame.position = nedPosition
            newNedFrame.coordinateTransformation = newNedC

            NEDtoECEFFrameConverter.convertNEDtoECEF(newNedFrame, newEcefFrame)

            val trueAfterGravityKinematics = ECEFKinematicsEstimator.estimateKinematicsAndReturnNew(
                TIME_INTERVAL_SECONDS,
                newEcefFrame,
                newEcefFrame
            )
            val measuredAfterGravityKinematics = BodyKinematicsGenerator.generate(
                TIME_INTERVAL_SECONDS,
                trueAfterGravityKinematics,
                errors,
                random
            )
            val afterMeanFx = measuredAfterGravityKinematics.fx
            val afterMeanFy = measuredAfterGravityKinematics.fy
            val afterMeanFz = measuredAfterGravityKinematics.fz

            sequence.setAfterMeanSpecificForceCoordinates(afterMeanFx, afterMeanFy, afterMeanFz)

            sequences.add(sequence)

            val accelerometerMeasurement = StandardDeviationBodyKinematics(
                measuredBeforeGravityKinematics,
                ACCUMULATED_STD,
                0.0
            )
            calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
        }
        calibrator.gyroscopeMeasurements.addAll(sequences)

        assertTrue(calibrator.isReadyToSolveCalibration)
        assertFalse(calibrator.running)

        justRun { accelerometerNonLinearInternalCalibrator.calibrate() }
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        justRun { gyroscopeNonLinearInternalCalibrator.calibrate() }
        calibrator.setPrivateProperty(
            "gyroscopeInternalCalibrator",
            gyroscopeNonLinearInternalCalibrator
        )

        justRun { magnetometerNonLinearInternalCalibrator.calibrate() }
        calibrator.setPrivateProperty(
            "magnetometerInternalCalibrator",
            magnetometerNonLinearInternalCalibrator
        )

        assertTrue(calibrator.calibrate())

        assertFalse(calibrator.running)
        verify(exactly = 1) {
            calibrationSolvingStartedListener.onCalibrationSolvingStarted(
                calibrator
            )
        }
        verify(exactly = 1) { calibrationCompletedListener.onCalibrationCompleted(calibrator) }
    }

    @Test
    fun calibrate_whenInternalAccelerometerFailure_setsAsNotRunning() {
        mockkStatic(Log::class) {
            every { Log.e(any(), any(), any()) }.returns(1)

            val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context
            )

            val accelerometerMeasurement = StandardDeviationBodyKinematics()
            val gyroscopeMeasurement =
                BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
            (1..calibrator.requiredMeasurements).forEach { _ ->
                calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
                calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
                calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
            }

            assertTrue(calibrator.isReadyToSolveCalibration)
            assertFalse(calibrator.running)

            every { accelerometerNonLinearInternalCalibrator.calibrate() }.throws(
                CalibrationException()
            )
            calibrator.setPrivateProperty(
                "accelerometerInternalCalibrator",
                accelerometerNonLinearInternalCalibrator
            )

            assertFalse(calibrator.calibrate())

            assertFalse(calibrator.running)
        }
    }

    @Test
    fun calibrate_whenFailureAndErrorListener_setsAsNotRunning() {
        mockkStatic(Log::class) {
            every { Log.e(any(), any(), any()) }.returns(1)

            val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                errorListener = errorListener
            )

            val accelerometerMeasurement = StandardDeviationBodyKinematics()
            val gyroscopeMeasurement =
                BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
            val magnetometerMeasurement = StandardDeviationBodyMagneticFluxDensity()
            (1..calibrator.requiredMeasurements).forEach { _ ->
                calibrator.accelerometerMeasurements.add(accelerometerMeasurement)
                calibrator.gyroscopeMeasurements.add(gyroscopeMeasurement)
                calibrator.magnetometerMeasurements.add(magnetometerMeasurement)
            }

            assertTrue(calibrator.isReadyToSolveCalibration)
            assertFalse(calibrator.running)

            every { accelerometerNonLinearInternalCalibrator.calibrate() }.throws(
                CalibrationException()
            )
            calibrator.setPrivateProperty(
                "accelerometerInternalCalibrator",
                accelerometerNonLinearInternalCalibrator
            )

            assertFalse(calibrator.calibrate())

            assertFalse(calibrator.running)
            verify(exactly = 1) {
                errorListener.onError(
                    calibrator,
                    CalibratorErrorReason.NUMERICAL_INSTABILITY_DURING_CALIBRATION
                )
            }
        }
    }

    @Test
    fun estimatedAccelerometerBiasX_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasX)
    }

    @Test
    fun estimatedAccelerometerBiasX_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasFx }.returns(estimatedBiasX)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasX, calibrator.estimatedAccelerometerBiasX)
    }

    @Test
    fun estimatedAccelerometerBiasX_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.biasX }.returns(estimatedBiasX)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasX, calibrator.estimatedAccelerometerBiasX)
    }

    @Test
    fun estimatedAccelerometerBiasY_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasY)
    }

    @Test
    fun estimatedAccelerometerBiasY_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasFy }.returns(estimatedBiasY)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasY, calibrator.estimatedAccelerometerBiasY)
    }

    @Test
    fun estimatedAccelerometerBiasY_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.biasY }.returns(estimatedBiasY)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasY, calibrator.estimatedAccelerometerBiasY)
    }

    @Test
    fun estimatedAccelerometerBiasZ_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasZ)
    }

    @Test
    fun estimatedAccelerometerBiasZ_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasFz }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasZ, calibrator.estimatedAccelerometerBiasZ)
    }

    @Test
    fun estimatedAccelerometerBiasZ_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.biasZ }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasZ, calibrator.estimatedAccelerometerBiasZ)
    }

    @Test
    fun estimatedAccelerometerBiasXAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasXAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasXAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasX, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.estimatedBiasFxAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasXAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasXAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasX, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.biasXAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasXAsMeasurement)
    }

    @Test
    fun getEstimatedAccelerometerBiasXAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsFalse() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))
    }

    @Test
    fun getEstimatedAccelerometerBiasXAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasFxAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasX
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))

        assertEquals(estimatedBiasX, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun getEstimatedAccelerometerBiasXAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasXAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasX
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasXAsMeasurement(acceleration))

        assertEquals(estimatedBiasX, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun estimatedAccelerometerBiasYAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasYAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasYAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasY, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.estimatedBiasFyAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasYAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasYAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasY, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.biasYAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasYAsMeasurement)
    }

    @Test
    fun getEstimatedAccelerometerBiasYAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsFalse() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))
    }

    @Test
    fun getEstimatedAccelerometerBiasYAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasFyAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasY
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))

        assertEquals(estimatedBiasY, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun getEstimatedAccelerometerBiasYAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasYAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasY
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasYAsMeasurement(acceleration))

        assertEquals(estimatedBiasY, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun estimatedAccelerometerBiasZAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasZAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasZAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasZ, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.estimatedBiasFzAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasZAsMeasurement)
    }

    @Test
    fun estimatedAccelerometerBiasZAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        val acceleration = Acceleration(estimatedBiasZ, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        every { internalCalibratorSpy.biasZAsAcceleration }.returns(acceleration)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(acceleration, calibrator.estimatedAccelerometerBiasZAsMeasurement)
    }

    @Test
    fun getEstimatedAccelerometerBiasZAsMeasurement_whenNoAccelerometerInternalCalibrator_returnsFalse() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertFalse(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))
    }

    @Test
    fun getEstimatedAccelerometerBiasZAsMeasurement_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasFzAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasZ
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))

        assertEquals(estimatedBiasZ, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun getEstimatedAccelerometerBiasZAsMeasurement_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasZAsAcceleration(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as Acceleration
            result.value = estimatedBiasZ
            result.unit = AccelerationUnit.METERS_PER_SQUARED_SECOND
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val acceleration = Acceleration(0.0, AccelerationUnit.METERS_PER_SQUARED_SECOND)
        assertTrue(calibrator.getEstimatedAccelerometerBiasZAsMeasurement(acceleration))

        assertEquals(estimatedBiasZ, acceleration.value.toDouble(), 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, acceleration.unit)
    }

    @Test
    fun estimatedAccelerometerBiasAsTriad_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))
        assertNull(calibrator.estimatedAccelerometerBiasAsTriad)
    }

    @Test
    fun estimatedAccelerometerBiasAsTriad_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        val triad = AccelerationTriad(
            AccelerationUnit.METERS_PER_SQUARED_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        every { internalCalibratorSpy.estimatedBiasAsTriad }.returns(triad)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(triad, calibrator.estimatedAccelerometerBiasAsTriad)
    }

    @Test
    fun estimatedAccelerometerBiasAsTriad_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        val triad = AccelerationTriad(
            AccelerationUnit.METERS_PER_SQUARED_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        every { internalCalibratorSpy.biasAsTriad }.returns(triad)
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertSame(triad, calibrator.estimatedAccelerometerBiasAsTriad)
    }

    @Test
    fun getEstimatedAccelerometerBiasAsTriad_whenNoAccelerometerInternalCalibrator_returnsFalse() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))

        val triad = AccelerationTriad()
        assertFalse(calibrator.getEstimatedAccelerometerBiasAsTriad(triad))
    }

    @Test
    fun getEstimatedAccelerometerBiasAsTriad_whenUnknownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasAsTriad(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AccelerationTriad
            result.setValueCoordinatesAndUnit(
                estimatedBiasX,
                estimatedBiasY,
                estimatedBiasZ,
                AccelerationUnit.METERS_PER_SQUARED_SECOND
            )
            return@answers true
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val triad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(triad))

        assertEquals(estimatedBiasX, triad.valueX, 0.0)
        assertEquals(estimatedBiasY, triad.valueY, 0.0)
        assertEquals(estimatedBiasZ, triad.valueZ, 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, triad.unit)
    }

    @Test
    fun getEstimatedAccelerometerBiasAsTriad_whenKnownBiasAccelerometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasAsTriad(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AccelerationTriad
            result.setValueCoordinatesAndUnit(
                estimatedBiasX,
                estimatedBiasY,
                estimatedBiasZ,
                AccelerationUnit.METERS_PER_SQUARED_SECOND
            )
        }
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        val triad = AccelerationTriad()
        assertTrue(calibrator.getEstimatedAccelerometerBiasAsTriad(triad))

        assertEquals(estimatedBiasX, triad.valueX, 0.0)
        assertEquals(estimatedBiasY, triad.valueY, 0.0)
        assertEquals(estimatedBiasZ, triad.valueZ, 0.0)
        assertEquals(AccelerationUnit.METERS_PER_SQUARED_SECOND, triad.unit)
    }

    @Test
    fun estimatedAccelerometerBiasStandardDeviationNorm_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("accelerometerInternalCalibrator"))

        assertNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)
    }

    @Test
    fun estimatedAccelerometerBiasStandardDeviationNorm_whenBiasUncertaintySourceAccelerometerInternalCalibrator_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAccelerometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasStandardDeviationNorm = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasStandardDeviationNorm }.returns(
            estimatedBiasStandardDeviationNorm
        )
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(
            estimatedBiasStandardDeviationNorm,
            calibrator.estimatedAccelerometerBiasStandardDeviationNorm
        )
    }

    @Test
    fun estimatedAccelerometerBiasStandardDeviationNorm_whenOtherAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasAndPositionAccelerometerCalibrator())
        calibrator.setPrivateProperty("accelerometerInternalCalibrator", internalCalibratorSpy)

        assertNull(calibrator.estimatedAccelerometerBiasStandardDeviationNorm)
    }

    @Test
    fun estimatedGyroscopeBiasX_whenNoGyroscopeInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasX)
    }

    @Test
    fun estimatedGyroscopeBiasX_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasX }.returns(estimatedBiasX)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasX, calibrator.estimatedGyroscopeBiasX)
    }

    @Test
    fun estimatedGyroscopeBiasX_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.biasX }.returns(estimatedBiasX)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasX, calibrator.estimatedGyroscopeBiasX)
    }

    @Test
    fun estimatedGyroscopeBiasY_whenNoGyroscopeInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasY)
    }

    @Test
    fun estimatedGyroscopeBiasY_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasY }.returns(estimatedBiasY)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasY, calibrator.estimatedGyroscopeBiasY)
    }

    @Test
    fun estimatedGyroscopeBiasY_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.biasY }.returns(estimatedBiasY)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasY, calibrator.estimatedGyroscopeBiasY)
    }

    @Test
    fun estimatedGyroscopeBiasZ_whenNoGyroscopeInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasZ)
    }

    @Test
    fun estimatedGyroscopeBiasZ_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasZ }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasZ, calibrator.estimatedGyroscopeBiasZ)
    }

    @Test
    fun estimatedGyroscopeBiasZ_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.biasZ }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedBiasZ, calibrator.estimatedGyroscopeBiasZ)
    }

    @Test
    fun estimatedGyroscopeBiasXAsMeasurement_whenNoGyroscopeInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasXAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasXAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasX, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.estimatedBiasAngularSpeedX }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasXAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasXAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasX, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.biasAngularSpeedX }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasXAsMeasurement)
    }

    @Test
    fun getEstimatedGyroscopeBiasXAsMeasurement_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        val w = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(w))
    }

    @Test
    fun getEstimatedGyroscopeBiasXAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasAngularSpeedX(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasX
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasX, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(w))

        assertEquals(estimatedBiasX, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun getEstimatedGyroscopeBiasXAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasAngularSpeedX(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasX
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasX, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasXAsMeasurement(w))

        assertEquals(estimatedBiasX, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun estimatedGyroscopeBiasYAsMeasurement_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasYAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasYAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasY, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.estimatedBiasAngularSpeedY }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasYAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasYAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasY, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.biasAngularSpeedY }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasYAsMeasurement)
    }

    @Test
    fun getEstimatedGyroscopeBiasYAsMeasurement_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        val w = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(w))
    }

    @Test
    fun getEstimatedGyroscopeBiasYAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasAngularSpeedY(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasY
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasY, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(w))

        assertEquals(estimatedBiasY, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun getEstimatedGyroscopeBiasYAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasY = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasAngularSpeedY(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasY
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasY, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasYAsMeasurement(w))

        assertEquals(estimatedBiasY, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun estimatedGyroscopeBiasZAsMeasurement_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasZAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasZAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.estimatedBiasAngularSpeedZ }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasZAsMeasurement)
    }

    @Test
    fun estimatedGyroscopeBiasZAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        val w = AngularSpeed(estimatedBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND)
        every { internalCalibratorSpy.biasAngularSpeedZ }.returns(w)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(w, calibrator.estimatedGyroscopeBiasZAsMeasurement)
    }

    @Test
    fun getEstimatedGyroscopeBiasZAsMeasurement_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        val w = AngularSpeed(0.0, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertFalse(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(w))
    }

    @Test
    fun getEstimatedGyroscopeBiasZAsMeasurement_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasAngularSpeedZ(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasZ
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
            return@answers true
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(w))

        assertEquals(estimatedBiasZ, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun getEstimatedGyroscopeBiasZAsMeasurement_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getBiasAngularSpeedZ(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeed
            result.value = estimatedBiasZ
            result.unit = AngularSpeedUnit.RADIANS_PER_SECOND
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val w = AngularSpeed(estimatedBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND)
        assertTrue(calibrator.getEstimatedGyroscopeBiasZAsMeasurement(w))

        assertEquals(estimatedBiasZ, w.value.toDouble(), 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, w.unit)
    }

    @Test
    fun estimatedGyroscopeBiasAsTriad_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        assertNull(calibrator.estimatedGyroscopeBiasAsTriad)
    }

    @Test
    fun estimatedGyroscopeBiasAsTriad_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        val triad = AngularSpeedTriad(
            AngularSpeedUnit.RADIANS_PER_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        every { internalCalibratorSpy.estimatedBiasAsTriad }.returns(triad)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertSame(triad, calibrator.estimatedGyroscopeBiasAsTriad)
    }

    @Test
    fun estimatedGyroscopeBiasAsTriad_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        val triad = AngularSpeedTriad(
            AngularSpeedUnit.RADIANS_PER_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        every { internalCalibratorSpy.biasX }.returns(estimatedBiasX)
        every { internalCalibratorSpy.biasY }.returns(estimatedBiasY)
        every { internalCalibratorSpy.biasZ }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(triad, calibrator.estimatedGyroscopeBiasAsTriad)
    }

    @Test
    fun getEstimatedGyroscopeBiasAsTriad_whenNoInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))
        val triad = AngularSpeedTriad()
        assertFalse(calibrator.getEstimatedGyroscopeBiasAsTriad(triad))
    }

    @Test
    fun getEstimatedGyroscopeBiasAsTriad_whenUnknownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedBiasAsTriad(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as AngularSpeedTriad
            result.setValueCoordinatesAndUnit(
                estimatedBiasX,
                estimatedBiasY,
                estimatedBiasZ,
                AngularSpeedUnit.RADIANS_PER_SECOND
            )
            return@answers true
        }
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val triad = AngularSpeedTriad(
            AngularSpeedUnit.RADIANS_PER_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(triad))

        assertEquals(estimatedBiasX, triad.valueX, 0.0)
        assertEquals(estimatedBiasY, triad.valueY, 0.0)
        assertEquals(estimatedBiasZ, triad.valueZ, 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, triad.unit)
    }

    @Test
    fun getEstimatedGyroscopeBiasAsTriad_whenKnownBiasGyroscopeInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasX = randomizer.nextDouble()
        val estimatedBiasY = randomizer.nextDouble()
        val estimatedBiasZ = randomizer.nextDouble()
        every { internalCalibratorSpy.biasX }.returns(estimatedBiasX)
        every { internalCalibratorSpy.biasY }.returns(estimatedBiasY)
        every { internalCalibratorSpy.biasZ }.returns(estimatedBiasZ)
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        val triad = AngularSpeedTriad(
            AngularSpeedUnit.RADIANS_PER_SECOND,
            estimatedBiasX,
            estimatedBiasY,
            estimatedBiasZ
        )
        assertTrue(calibrator.getEstimatedGyroscopeBiasAsTriad(triad))

        assertEquals(estimatedBiasX, triad.valueX, 0.0)
        assertEquals(estimatedBiasY, triad.valueY, 0.0)
        assertEquals(estimatedBiasZ, triad.valueZ, 0.0)
        assertEquals(AngularSpeedUnit.RADIANS_PER_SECOND, triad.unit)
    }

    @Test
    fun estimatedGyroscopeBiasStandardDeviationNorm_whenNoAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("gyroscopeInternalCalibrator"))

        assertNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)
    }

    @Test
    fun estimatedGyroscopeBiasStandardDeviationNorm_whenBiasUncertaintySourceAccelerometerInternalCalibrator_returnsExpectedValue() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(EasyGyroscopeCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedBiasStandardDeviationNorm = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedBiasStandardDeviationNorm }.returns(
            estimatedBiasStandardDeviationNorm
        )
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertEquals(
            estimatedBiasStandardDeviationNorm,
            calibrator.estimatedGyroscopeBiasStandardDeviationNorm
        )
    }

    @Test
    fun estimatedGyroscopeBiasStandardDeviationNorm_whenOtherAccelerometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownBiasEasyGyroscopeCalibrator())
        calibrator.setPrivateProperty("gyroscopeInternalCalibrator", internalCalibratorSpy)

        assertNull(calibrator.estimatedGyroscopeBiasStandardDeviationNorm)
    }

    @Test
    fun estimatedMagnetometerHardIronX_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronX)
    }

    @Test
    fun estimatedMagnetometerHardIronX_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedHardIronX }.returns(estimatedHardIronX)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronX, calibrator.estimatedMagnetometerHardIronX)
    }

    @Test
    fun estimatedMagnetometerHardIronX_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        every { internalCalibratorSpy.hardIronX }.returns(estimatedHardIronX)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronX, calibrator.estimatedMagnetometerHardIronX)
    }

    @Test
    fun estimatedMagnetometerHardIronY_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronY)
    }

    @Test
    fun estimatedMagnetometerHardIronY_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedHardIronY }.returns(estimatedHardIronY)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronY, calibrator.estimatedMagnetometerHardIronY)
    }

    @Test
    fun estimatedMagnetometerHardIronY_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        every { internalCalibratorSpy.hardIronY }.returns(estimatedHardIronY)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronY, calibrator.estimatedMagnetometerHardIronY)
    }

    @Test
    fun estimatedMagnetometerHardIronZ_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronZ)
    }

    @Test
    fun estimatedMagnetometerHardIronZ_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.estimatedHardIronZ }.returns(estimatedHardIronZ)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronZ, calibrator.estimatedMagnetometerHardIronZ)
    }

    @Test
    fun estimatedMagnetometerHardIronZ_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.hardIronZ }.returns(estimatedHardIronZ)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertEquals(estimatedHardIronZ, calibrator.estimatedMagnetometerHardIronZ)
    }

    @Test
    fun estimatedMagnetometerHardIronXAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronXAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronXAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronX, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.estimatedHardIronXAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronXAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronXAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronX, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.hardIronXAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronXAsMeasurement)
    }

    @Test
    fun getEstimatedMagnetometerHardIronXAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))
    }

    @Test
    fun getEstimatedMagnetometerHardIronXAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedHardIronXAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronX
            result.unit = MagneticFluxDensityUnit.TESLA
            return@answers true
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))

        assertEquals(estimatedHardIronX, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun getEstimatedMagnetometerHardIronXAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        every { internalCalibratorSpy.getHardIronXAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronX
            result.unit = MagneticFluxDensityUnit.TESLA
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronXAsMeasurement(b))

        assertEquals(estimatedHardIronX, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun estimatedMagnetometerHardIronYAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronYAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronYAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronY, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.estimatedHardIronYAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronYAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronYAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronY, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.hardIronYAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronYAsMeasurement)
    }

    @Test
    fun getEstimatedMagnetometerHardIronYAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))
    }

    @Test
    fun getEstimatedMagnetometerHardIronYAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedHardIronYAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronY
            result.unit = MagneticFluxDensityUnit.TESLA
            return@answers true
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))

        assertEquals(estimatedHardIronY, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun getEstimatedMagnetometerHardIronYAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronY = randomizer.nextDouble()
        every { internalCalibratorSpy.getHardIronYAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronY
            result.unit = MagneticFluxDensityUnit.TESLA
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronYAsMeasurement(b))

        assertEquals(estimatedHardIronY, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun estimatedMagnetometerHardIronZAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronZAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronZAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronZ, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.estimatedHardIronZAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronZAsMeasurement)
    }

    @Test
    fun estimatedMagnetometerHardIronZAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        val b = MagneticFluxDensity(estimatedHardIronZ, MagneticFluxDensityUnit.TESLA)
        every { internalCalibratorSpy.hardIronZAsMagneticFluxDensity }.returns(b)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(b, calibrator.estimatedMagnetometerHardIronZAsMeasurement)
    }

    @Test
    fun getEstimatedMagnetometerHardIronZAsMeasurement_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertFalse(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))
    }

    @Test
    fun getEstimatedMagnetometerHardIronZAsMeasurement_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedHardIronZAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronZ
            result.unit = MagneticFluxDensityUnit.TESLA
            return@answers true
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))

        assertEquals(estimatedHardIronZ, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun getEstimatedMagnetometerHardIronZAsMeasurement_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getHardIronZAsMagneticFluxDensity(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensity
            result.value = estimatedHardIronZ
            result.unit = MagneticFluxDensityUnit.TESLA
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val b = MagneticFluxDensity(0.0, MagneticFluxDensityUnit.TESLA)
        assertTrue(calibrator.getEstimatedMagnetometerHardIronZAsMeasurement(b))

        assertEquals(estimatedHardIronZ, b.value.toDouble(), 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, b.unit)
    }

    @Test
    fun estimatedMagnetometerHardIronAsTriad_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        assertNull(calibrator.estimatedMagnetometerHardIronAsTriad)
    }

    @Test
    fun estimatedMagnetometerHardIronAsTriad_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val estimatedHardIronY = randomizer.nextDouble()
        val estimatedHardIronZ = randomizer.nextDouble()
        val triad = MagneticFluxDensityTriad(
            MagneticFluxDensityUnit.TESLA,
            estimatedHardIronX,
            estimatedHardIronY,
            estimatedHardIronZ
        )
        every { internalCalibratorSpy.estimatedHardIronAsTriad }.returns(triad)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(triad, calibrator.estimatedMagnetometerHardIronAsTriad)
    }

    @Test
    fun estimatedMagnetometerHardIronAsTriad_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val estimatedHardIronY = randomizer.nextDouble()
        val estimatedHardIronZ = randomizer.nextDouble()
        val triad = MagneticFluxDensityTriad(
            MagneticFluxDensityUnit.TESLA,
            estimatedHardIronX,
            estimatedHardIronY,
            estimatedHardIronZ
        )
        every { internalCalibratorSpy.hardIronAsTriad }.returns(triad)
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        assertSame(triad, calibrator.estimatedMagnetometerHardIronAsTriad)
    }

    @Test
    fun getEstimatedMagnetometerHardIronAsTriad_whenNoMagnetometerInternalCalibrator_returnsNull() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        assertNull(calibrator.getPrivateProperty("magnetometerInternalCalibrator"))
        val triad = MagneticFluxDensityTriad()
        assertFalse(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))
    }

    @Test
    fun getEstimatedMagnetometerHardIronAsTriad_whenUnknownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val estimatedHardIronY = randomizer.nextDouble()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getEstimatedHardIronAsTriad(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensityTriad
            result.setValueCoordinatesAndUnit(
                estimatedHardIronX,
                estimatedHardIronY,
                estimatedHardIronZ,
                MagneticFluxDensityUnit.TESLA
            )
            return@answers true
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))

        assertEquals(estimatedHardIronX, triad.valueX, 0.0)
        assertEquals(estimatedHardIronY, triad.valueY, 0.0)
        assertEquals(estimatedHardIronZ, triad.valueZ, 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, triad.unit)
    }

    @Test
    fun getEstimatedMagnetometerHardIronAsTriad_whenKnownHardIronMagnetometerInternalCalibrator_callsInternalCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(context)

        val internalCalibratorSpy = spyk(KnownHardIronPositionAndInstantMagnetometerCalibrator())
        val randomizer = UniformRandomizer()
        val estimatedHardIronX = randomizer.nextDouble()
        val estimatedHardIronY = randomizer.nextDouble()
        val estimatedHardIronZ = randomizer.nextDouble()
        every { internalCalibratorSpy.getHardIronAsTriad(any()) }.answers { answer ->
            val result = answer.invocation.args[0] as MagneticFluxDensityTriad
            result.setValueCoordinatesAndUnit(
                estimatedHardIronX,
                estimatedHardIronY,
                estimatedHardIronZ,
                MagneticFluxDensityUnit.TESLA
            )
        }
        calibrator.setPrivateProperty("magnetometerInternalCalibrator", internalCalibratorSpy)

        val triad = MagneticFluxDensityTriad()
        assertTrue(calibrator.getEstimatedMagnetometerHardIronAsTriad(triad))

        assertEquals(estimatedHardIronX, triad.valueX, 0.0)
        assertEquals(estimatedHardIronY, triad.valueY, 0.0)
        assertEquals(estimatedHardIronZ, triad.valueZ, 0.0)
        assertEquals(MagneticFluxDensityUnit.TESLA, triad.unit)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLocation_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true,
            location = location
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertSame(location, calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasAndPositionAccelerometerCalibrator
        assertTrue(location.toNEDPosition().equals(internalCalibrator2.nedPosition,
            ABSOLUTE_ERROR
        ))
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustGroundTruthBiasBiasNotSetAndCommonAxisNotUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustGroundTruthBiasBiasSetAndCommonAxisNotUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustGroundTruthBiasBiasNotSetAndCommonAxisUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustNoGroundTruthBiasBiasNotSetAndCommonAxisNotUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 = internalCalibrator as KnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustNoGroundTruthBiasBiasNotAndCommonAxisNotUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 = internalCalibrator as KnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenNonRobustNoGroundTruthBiasAndPositionBiasNotSetAndCommonAxisUsed_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 = internalCalibrator as KnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACGroundTruthBiasBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACGroundTruthBiasBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACGroundTruthBiasBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)

        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACGroundTruthBiasMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACGroundTruthBiasBiasNotSetAndRobustThreshold() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACGroundTruthBiasBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACGroundTruthBiasBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACGroundTruthBiasMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACGroundTruthBiasBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACGroundTruthBiasBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACGroundTruthBiasBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACGroundTruthBiasMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSGroundTruthBiasBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSGroundTruthBiasBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSGroundTruthBiasBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSGroundTruthBiasMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSGroundTruthBiasBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSGroundTruthBiasBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSGroundTruthBiasBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.accelerometerRobustStopThresholdFactor,
            0.0
        )
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasAndGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredAccelerometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSGroundTruthBiasMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = true
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertTrue(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val location = getLocation()
        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenRANSACMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            location = location,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNotNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenMSACMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROSACMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenLMedSMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSBiasNotSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSBiasSetAndRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialBiasX = randomizer.nextDouble()
        val initialBiasY = randomizer.nextDouble()
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("accelerometerInitialBiasX", initialBiasX)
        calibrator.setPrivateProperty("accelerometerInitialBiasY", initialBiasY)
        calibrator.setPrivateProperty("accelerometerInitialBiasZ", initialBiasZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSBiasNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.accelerometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.accelerometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val internalCalibrator: AccelerometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownGravityNormAccelerometerCalibrator
        assertEquals(gravityNorm, internalCalibrator2.groundTruthGravityNorm, 0.0)
        assertSame(calibrator.accelerometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(
            calibrator.accelerometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildAccelerometerInternalCalibrator_whenPROMedSMissingBaseNoiseLevel_throwsIllegalStateException() {
        val location = getLocation()
        val calibrator = StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
            context,
            isAccelerometerGroundTruthInitialBias = false
        )

        val randomizer = UniformRandomizer()
        val specificForceStandardDeviation = randomizer.nextDouble()
        every { measurement.specificForceStandardDeviation }.returns(specificForceStandardDeviation)
        every { measurement.angularRateStandardDeviation }.returns(0.0)
        (1..13).forEach { _ ->
            calibrator.accelerometerMeasurements.add(measurement)
        }

        calibrator.isAccelerometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setAccelerometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.accelerometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.accelerometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.accelerometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.accelerometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.accelerometerRobustThreshold = null
        calibrator.accelerometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.accelerometerRobustMethod)
        assertFalse(calibrator.isAccelerometerGroundTruthInitialBias)
        assertNull(calibrator.location)
        assertEquals(ROBUST_CONFIDENCE, calibrator.accelerometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.accelerometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.accelerometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.accelerometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.accelerometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.accelerometerBaseNoiseLevel)

        val gravityNorm = GravityHelper.getGravityNormForLocation(location)
        calibrator.setPrivateProperty("gravityNorm", gravityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildAccelerometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenNonRobustGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(0.0, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ma, internalCalibrator2.accelerometerMa)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerSx_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerSy_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerSz_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMxy_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMxz_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMyx_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMyz_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMzx_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(null)
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(
            ma.getElementAt(
                2,
                1
            )
        )
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMissingAccelerometerMzy_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val ma = generateMa()
        every { accelerometerNonLinearInternalCalibrator.estimatedSx }.returns(
            ma.getElementAt(
                0,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSy }.returns(
            ma.getElementAt(
                1,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedSz }.returns(
            ma.getElementAt(
                2,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxy }.returns(
            ma.getElementAt(
                0,
                1
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMxz }.returns(
            ma.getElementAt(
                0,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyx }.returns(
            ma.getElementAt(
                1,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMyz }.returns(
            ma.getElementAt(
                1,
                2
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzx }.returns(
            ma.getElementAt(
                2,
                0
            )
        )
        every { accelerometerNonLinearInternalCalibrator.estimatedMzy }.returns(null)
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerNonLinearInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenNonRobustGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenNonRobustNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as EasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenNonRobustNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 = internalCalibrator as EasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(
            ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0
        )
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACNoGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenRANSACNoGroundTruthBiasNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertNull(calibrator.gyroscopeBaseNoiseLevel)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACNoGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenMSACNoGroundTruthBiasNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertNull(calibrator.gyroscopeBaseNoiseLevel)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACNoGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROSACNoGroundTruthBiasNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertNull(calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSNoGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenLMedSNoGroundTruthBiasNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertNull(calibrator.gyroscopeBaseNoiseLevel)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.biasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.biasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.biasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSNoGroundTruthBiasAndNoInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        assertNull(calibrator.gyroscopeInitialBiasX)
        assertNull(calibrator.gyroscopeInitialBiasY)
        assertNull(calibrator.gyroscopeInitialBiasZ)
        assertNull(calibrator.estimatedAccelerometerBiasX)
        assertNull(calibrator.estimatedAccelerometerBiasY)
        assertNull(calibrator.estimatedAccelerometerBiasZ)

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSNoGroundTruthBiasAndInitialBias_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialBiasX = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasX", initialBiasX)
        val initialBiasY = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasY", initialBiasY)
        val initialBiasZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("gyroscopeInitialBiasZ", initialBiasZ)

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(initialBiasX, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(initialBiasY, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(initialBiasZ, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(accelerometerBiasX, internalCalibrator2.accelerometerBiasX, 0.0)
        assertEquals(accelerometerBiasY, internalCalibrator2.accelerometerBiasY, 0.0)
        assertEquals(accelerometerBiasZ, internalCalibrator2.accelerometerBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = true
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..16).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertTrue(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownBiasEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.biasX, 0.0)
        assertEquals(0.0, internalCalibrator2.biasY, 0.0)
        assertEquals(0.0, internalCalibrator2.biasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(16, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSNoGroundTruthBiasAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.gyroscopeRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.gyroscopeBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val internalCalibrator: GyroscopeNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustEasyGyroscopeCalibrator
        assertSame(calibrator.gyroscopeMeasurements, internalCalibrator2.sequences)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertTrue(internalCalibrator2.isGDependentCrossBiasesEstimated)
        assertEquals(gg, internalCalibrator2.initialGg)
        assertEquals(0.0, internalCalibrator2.initialBiasX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialBiasZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(calibrator.gyroscopeMeasurements.size, internalCalibrator2.qualityScores.size)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(19, internalCalibrator2.minimumRequiredMeasurementsOrSequences)
        assertEquals(
            calibrator.minimumRequiredGyroscopeMeasurements,
            internalCalibrator2.minimumRequiredMeasurementsOrSequences
        )
    }

    @Test
    fun buildGyroscopeInternalCalibrator_whenPROMedSNoGroundTruthBiasNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isGyroscopeGroundTruthInitialBias = false
            )

        val measurement = BodyKinematicsSequence<StandardDeviationTimedBodyKinematics>()
        (1..19).forEach { _ ->
            calibrator.gyroscopeMeasurements.add(measurement)
        }

        calibrator.isGyroscopeCommonAxisUsed = true
        calibrator.isGDependentCrossBiasesEstimated = true
        val gg = Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS)
        Matrix.fillWithUniformRandomValues(0.0, 1.0, gg)
        calibrator.gyroscopeInitialGg = gg

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setGyroscopeInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.gyroscopeRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.gyroscopeRobustConfidence = ROBUST_CONFIDENCE
        calibrator.gyroscopeRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.gyroscopeRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.gyroscopeRobustThreshold = null
        calibrator.gyroscopeRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.gyroscopeRobustMethod)
        assertFalse(calibrator.isGyroscopeGroundTruthInitialBias)
        assertEquals(ROBUST_CONFIDENCE, calibrator.gyroscopeRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.gyroscopeRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.gyroscopeRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.gyroscopeRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.gyroscopeRobustThresholdFactor, 0.0)
        assertNull(calibrator.gyroscopeBaseNoiseLevel)

        val accelerometerBiasX = randomizer.nextDouble()
        val accelerometerBiasY = randomizer.nextDouble()
        val accelerometerBiasZ = randomizer.nextDouble()
        val ma = generateMa()
        every { accelerometerInternalCalibrator.biasX }.returns(accelerometerBiasX)
        every { accelerometerInternalCalibrator.biasY }.returns(accelerometerBiasY)
        every { accelerometerInternalCalibrator.biasZ }.returns(accelerometerBiasZ)
        every { accelerometerInternalCalibrator.estimatedSx }.returns(ma.getElementAt(0, 0))
        every { accelerometerInternalCalibrator.estimatedSy }.returns(ma.getElementAt(1, 1))
        every { accelerometerInternalCalibrator.estimatedSz }.returns(ma.getElementAt(2, 2))
        every { accelerometerInternalCalibrator.estimatedMxy }.returns(ma.getElementAt(0, 1))
        every { accelerometerInternalCalibrator.estimatedMxz }.returns(ma.getElementAt(0, 2))
        every { accelerometerInternalCalibrator.estimatedMyx }.returns(ma.getElementAt(1, 0))
        every { accelerometerInternalCalibrator.estimatedMyz }.returns(ma.getElementAt(1, 2))
        every { accelerometerInternalCalibrator.estimatedMzx }.returns(ma.getElementAt(2, 0))
        every { accelerometerInternalCalibrator.estimatedMzy }.returns(ma.getElementAt(2, 1))
        calibrator.setPrivateProperty(
            "accelerometerInternalCalibrator",
            accelerometerInternalCalibrator
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildGyroscopeInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenNoInitialMagneticFluxDensityNorm_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        assertNull(calibrator.initialMagneticFluxDensityNorm)

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is java.lang.IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLocation_buildsExpectedCalibrator() {
        val location = getLocation()
        val worldMagneticModel = WorldMagneticModel()
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                location,
                worldMagneticModel = worldMagneticModel,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        assertNull(calibrator.initialMagneticFluxDensityNorm)
        assertSame(location, calibrator.location)
        assertNotNull(calibrator.timestamp)
        assertSame(worldMagneticModel, calibrator.worldMagneticModel)
        assertFalse(calibrator.isInitialMagneticFluxDensityNormMeasured)

        val measurement = StandardDeviationBodyMagneticFluxDensity()
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(measurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)

        assertNull(calibrator.initialMagneticFluxDensityNorm)

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownHardIronPositionAndInstantMagnetometerCalibrator
        assertNull(internalCalibrator2.groundTruthMagneticFluxDensityNorm)
        assertTrue(location.toNEDPosition().equals(internalCalibrator2.nedPosition,
            ABSOLUTE_ERROR
        ))
        val calendar = GregorianCalendar()
        val timestamp = calibrator.timestamp
        requireNotNull(timestamp)
        calendar.time = timestamp
        val year = WMMEarthMagneticFluxDensityEstimator.convertTime(calendar)
        assertEquals(year, internalCalibrator2.year, 0.0)
        assertSame(worldMagneticModel, internalCalibrator2.magneticModel)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenNonRobustGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val measurement = StandardDeviationBodyMagneticFluxDensity()
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(measurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenNonRobustGroundTruthHardIronSetAndCommonAxisUsed_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val measurement = StandardDeviationBodyMagneticFluxDensity()
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(measurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenNonRobustGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val measurement = StandardDeviationBodyMagneticFluxDensity()
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(measurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenNonRobustAndGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val measurement = StandardDeviationBodyMagneticFluxDensity()
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(measurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )

        assertNull(calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as KnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as RANSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronNotSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenRANSACGroundTruthHardIronSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.RANSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.RANSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as MSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronNotSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenMSACGroundTruthHardIronSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.MSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.MSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROSACRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD_FACTOR * baseNoiseLevel, internalCalibrator2.threshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronNotSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROSACGroundTruthHardIronSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROSAC
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROSAC, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val randomizer = UniformRandomizer()
        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as LMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronNotSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenLMedSGroundTruthHardIronSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val randomizer = UniformRandomizer()
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.LMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.LMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronNotSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronNotSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronSetAndNoCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronSetAndCommonAxis_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = true

        val initialHardIronX = randomizer.nextDouble()
        val initialHardIronY = randomizer.nextDouble()
        val initialHardIronZ = randomizer.nextDouble()
        calibrator.setPrivateProperty("magnetometerInitialHardIronX", initialHardIronX)
        calibrator.setPrivateProperty("magnetometerInitialHardIronY", initialHardIronY)
        calibrator.setPrivateProperty("magnetometerInitialHardIronZ", initialHardIronZ)
        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = ROBUST_THRESHOLD

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        requireNotNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD, robustThreshold, 0.0)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertTrue(internalCalibrator2.isCommonAxisUsed)
        assertEquals(initialHardIronX, internalCalibrator2.hardIronX, 0.0)
        assertEquals(initialHardIronY, internalCalibrator2.hardIronY, 0.0)
        assertEquals(initialHardIronZ, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(ROBUST_THRESHOLD, internalCalibrator2.stopThreshold, 0.0)
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(7, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronNotSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.initialHardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.initialHardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(13, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronSetAndNoRobustThreshold_buildsExpectedCalibrator() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR
        calibrator.magnetometerRobustStopThresholdFactor = ROBUST_STOP_THRESHOLD_FACTOR

        val generator: AccelerometerGyroscopeAndMagnetometerMeasurementGenerator? =
            calibrator.getPrivateProperty("generator")
        requireNotNull(generator)
        val generatorSpy = spyk(generator)
        val baseNoiseLevel = randomizer.nextDouble()
        every { generatorSpy.magnetometerBaseNoiseLevel }.returns(baseNoiseLevel)
        calibrator.setPrivateProperty("generator", generatorSpy)

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertEquals(
            ROBUST_STOP_THRESHOLD_FACTOR,
            calibrator.magnetometerRobustStopThresholdFactor,
            0.0
        )
        assertEquals(baseNoiseLevel, calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val internalCalibrator: MagnetometerNonLinearCalibrator? =
            calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator")
        requireNotNull(internalCalibrator)

        // check
        val internalCalibrator2 =
            internalCalibrator as PROMedSRobustKnownHardIronMagneticFluxDensityNormMagnetometerCalibrator
        assertEquals(initialMagneticFluxDensityNorm, calibrator.initialMagneticFluxDensityNorm)
        assertSame(calibrator.magnetometerMeasurements, internalCalibrator2.measurements)
        assertFalse(internalCalibrator2.isCommonAxisUsed)
        assertEquals(0.0, internalCalibrator2.hardIronX, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronY, 0.0)
        assertEquals(0.0, internalCalibrator2.hardIronZ, 0.0)
        assertEquals(initialSx, internalCalibrator2.initialSx, 0.0)
        assertEquals(initialSy, internalCalibrator2.initialSy, 0.0)
        assertEquals(initialSz, internalCalibrator2.initialSz, 0.0)
        assertEquals(initialMxy, internalCalibrator2.initialMxy, 0.0)
        assertEquals(initialMxz, internalCalibrator2.initialMxz, 0.0)
        assertEquals(initialMyx, internalCalibrator2.initialMyx, 0.0)
        assertEquals(initialMyz, internalCalibrator2.initialMyz, 0.0)
        assertEquals(initialMzx, internalCalibrator2.initialMzx, 0.0)
        assertEquals(initialMzy, internalCalibrator2.initialMzy, 0.0)
        assertEquals(ROBUST_CONFIDENCE, internalCalibrator2.confidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, internalCalibrator2.maxIterations)
        assertEquals(ROBUST_PRELIMINARY_SUBSET_SIZE, internalCalibrator2.preliminarySubsetSize)
        assertEquals(
            ROBUST_THRESHOLD_FACTOR * ROBUST_STOP_THRESHOLD_FACTOR * baseNoiseLevel,
            internalCalibrator2.stopThreshold,
            0.0
        )
        assertEquals(
            calibrator.magnetometerMeasurements.size,
            internalCalibrator2.qualityScores.size
        )

        assertTrue(internalCalibrator2.isReady)
        assertEquals(10, internalCalibrator2.minimumRequiredMeasurements)
        assertEquals(
            calibrator.minimumRequiredMagnetometerMeasurements,
            internalCalibrator2.minimumRequiredMeasurements
        )
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronNotSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = false
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertFalse(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    @Test
    fun buildMagnetometerInternalCalibrator_whenPROMedSGroundTruthHardIronSetNoRobustThresholdAndMissingBaseNoiseLevel_throwsIllegalStateException() {
        val calibrator =
            StaticIntervalAccelerometerGyroscopeAndMagnetometerCalibrator(
                context,
                isMagnetometerGroundTruthInitialHardIron = true
            )

        val randomizer = UniformRandomizer()
        val magneticFluxDensityStandardDeviation = randomizer.nextDouble()
        every { magneticFluxMeasurement.magneticFluxDensityStandardDeviation }.returns(
            magneticFluxDensityStandardDeviation
        )
        (1..13).forEach { _ ->
            calibrator.magnetometerMeasurements.add(magneticFluxMeasurement)
        }

        calibrator.isMagnetometerCommonAxisUsed = false

        val initialSx = randomizer.nextDouble()
        val initialSy = randomizer.nextDouble()
        val initialSz = randomizer.nextDouble()
        val initialMxy = randomizer.nextDouble()
        val initialMxz = randomizer.nextDouble()
        val initialMyx = randomizer.nextDouble()
        val initialMyz = randomizer.nextDouble()
        val initialMzx = randomizer.nextDouble()
        val initialMzy = randomizer.nextDouble()
        calibrator.setMagnetometerInitialScalingFactorsAndCrossCouplingErrors(
            initialSx,
            initialSy,
            initialSz,
            initialMxy,
            initialMxz,
            initialMyx,
            initialMyz,
            initialMzx,
            initialMzy
        )
        calibrator.magnetometerRobustMethod = RobustEstimatorMethod.PROMEDS
        calibrator.magnetometerRobustConfidence = ROBUST_CONFIDENCE
        calibrator.magnetometerRobustMaxIterations = ROBUST_MAX_ITERATIONS
        calibrator.magnetometerRobustPreliminarySubsetSize = ROBUST_PRELIMINARY_SUBSET_SIZE
        calibrator.magnetometerRobustThreshold = null
        calibrator.magnetometerRobustThresholdFactor = ROBUST_THRESHOLD_FACTOR

        assertEquals(RobustEstimatorMethod.PROMEDS, calibrator.magnetometerRobustMethod)
        assertTrue(calibrator.isMagnetometerGroundTruthInitialHardIron)
        assertEquals(ROBUST_CONFIDENCE, calibrator.magnetometerRobustConfidence, 0.0)
        assertEquals(ROBUST_MAX_ITERATIONS, calibrator.magnetometerRobustMaxIterations)
        assertEquals(
            ROBUST_PRELIMINARY_SUBSET_SIZE,
            calibrator.magnetometerRobustPreliminarySubsetSize
        )
        val robustThreshold = calibrator.magnetometerRobustThreshold
        assertNull(robustThreshold)
        assertEquals(ROBUST_THRESHOLD_FACTOR, calibrator.magnetometerRobustThresholdFactor, 0.0)
        assertNull(calibrator.magnetometerBaseNoiseLevel)

        val initialMagneticFluxDensityNorm = randomizer.nextDouble()
        calibrator.setPrivateProperty(
            "initialMagneticFluxDensityNorm",
            initialMagneticFluxDensityNorm
        )

        val ex = assertThrows(InvocationTargetException::class.java) {
            assertNull(calibrator.callPrivateFuncWithResult("buildMagnetometerInternalCalibrator"))
        }
        assertTrue(ex.cause is IllegalStateException)
    }

    private fun getLocation(): Location {
        val randomizer = UniformRandomizer()
        val latitudeDegrees = randomizer.nextDouble(MIN_LATITUDE_DEGREES, MAX_LATITUDE_DEGREES)
        val longitudeDegrees =
            randomizer.nextDouble(MIN_LONGITUDE_DEGREES, MAX_LONGITUDE_DEGREES)
        val height = randomizer.nextDouble(MIN_HEIGHT, MAX_HEIGHT)

        every { location.latitude }.returns(latitudeDegrees)
        every { location.longitude }.returns(longitudeDegrees)
        every { location.altitude }.returns(height)

        return location
    }

    private companion object {
        const val MA_SIZE = 3
        const val MM_SIZE = 3

        const val MIN_LATITUDE_DEGREES = -90.0
        const val MAX_LATITUDE_DEGREES = 90.0

        const val MIN_LONGITUDE_DEGREES = -180.0
        const val MAX_LONGITUDE_DEGREES = 180.0

        const val MIN_HEIGHT = -100.0
        const val MAX_HEIGHT = 3000.0

        const val TIME_INTERVAL_SECONDS = 0.02

        const val MIN_ANGLE_DEGREES = -180.0
        const val MAX_ANGLE_DEGREES = 180.0

        const val MIN_ANGLE_VARIATION_DEGREES = -2.0
        const val MAX_ANGLE_VARIATION_DEGREES = 2.0

        const val INITIAL_STATIC_SAMPLES = 2500

        const val THRESHOLD_FACTOR = 3.0

        const val INSTANTANEOUS_NOISE_LEVEL_FACTOR = 3.0

        const val BASE_NOISE_LEVEL_ABSOLUTE_THRESHOLD = 1e-5

        const val WINDOW_SIZE = 51

        const val REQUIRED_MEASUREMENTS = 30

        const val ROBUST_CONFIDENCE = 0.9

        const val ROBUST_MAX_ITERATIONS = 1000

        const val ROBUST_PRELIMINARY_SUBSET_SIZE = 19

        const val ROBUST_THRESHOLD = 1e-5

        const val ROBUST_THRESHOLD_FACTOR = 2.0

        const val ROBUST_STOP_THRESHOLD_FACTOR = 1e-3

        const val ACCUMULATED_STD = 0.007

        const val MICRO_G_TO_METERS_PER_SECOND_SQUARED = 9.80665E-6
        const val DEG_TO_RAD = 0.01745329252

        const val ABSOLUTE_ERROR = 1e-6

        const val MIN_HARD_IRON = -1e-5
        const val MAX_HARD_IRON = 1e-5

        const val MIN_SOFT_IRON = -1e-6
        const val MAX_SOFT_IRON = 1e-6

        const val MAGNETOMETER_NOISE_STD = 200e-9

        fun generateBa(): Matrix {
            return Matrix.newFromArray(
                doubleArrayOf(
                    900 * MICRO_G_TO_METERS_PER_SECOND_SQUARED,
                    -1300 * MICRO_G_TO_METERS_PER_SECOND_SQUARED,
                    800 * MICRO_G_TO_METERS_PER_SECOND_SQUARED
                )
            )
        }

        fun generateBg(): Matrix {
            return Matrix.newFromArray(
                doubleArrayOf(
                    -9 * DEG_TO_RAD / 3600.0,
                    13 * DEG_TO_RAD / 3600.0,
                    -8 * DEG_TO_RAD / 3600.0
                )
            )
        }

        fun generateMa(): Matrix {
            val result = Matrix(3, 3)
            result.fromArray(
                doubleArrayOf(
                    500e-6, -300e-6, 200e-6,
                    -150e-6, -600e-6, 250e-6,
                    -250e-6, 100e-6, 450e-6
                ), false
            )
            return result
        }

        fun generateGeneralMg(): Matrix {
            val result = Matrix(3, 3)
            result.fromArray(
                doubleArrayOf(
                    400e-6, -300e-6, 250e-6,
                    -300e-6, -300e-6, -150e-6,
                    250e-6, -150e-6, -350e-6
                ), false
            )
            return result
        }

        fun getAccelNoiseRootPSD(): Double {
            return 100.0 * MICRO_G_TO_METERS_PER_SECOND_SQUARED
        }

        fun getGyroNoiseRootPSD(): Double {
            return 0.01 * DEG_TO_RAD / 60.0
        }

        fun generateHardIron(): DoubleArray {
            val result = DoubleArray(BodyMagneticFluxDensity.COMPONENTS)
            val randomizer = UniformRandomizer()
            randomizer.fill(result, MIN_HARD_IRON, MAX_HARD_IRON)
            return result
        }

        fun generateSoftIron(): Matrix? {
            return try {
                Matrix.createWithUniformRandomValues(
                    BodyMagneticFluxDensity.COMPONENTS,
                    BodyMagneticFluxDensity.COMPONENTS,
                    MIN_SOFT_IRON,
                    MAX_SOFT_IRON
                )
            } catch (_: WrongSizeException) {
                // never happens
                null
            }
        }
    }
}